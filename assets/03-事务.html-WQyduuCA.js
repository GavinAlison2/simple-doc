import{_ as a,c as i,e as l,o as t}from"./app-DN6Q4pKI.js";const s={};function r(n,e){return t(),i("div",null,e[0]||(e[0]=[l('<h1 id="_03-事务" tabindex="-1"><a class="header-anchor" href="#_03-事务"><span>03-事务</span></a></h1><h2 id="事务的概念" tabindex="-1"><a class="header-anchor" href="#事务的概念"><span>事务的概念</span></a></h2><p>事务是指一组数据库操作，要么都成功，要么都失败。事务具有四个属性：原子性、一致性、隔离性、持久性。</p><ul><li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li><li>一致性（Consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li><li>隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（Durability）：持续性也称永久性，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li></ul><p>事务ACID、隔离级别</p><ul><li>事务隔离级别,脏读,不可重复读,幻读</li><li>读未提交（read-uncommitted），是，是,是</li><li>不可重复读（read-committed），否，是，是</li><li>可重复读（repeatable-read）， 否，否，是</li><li>串行化（serializable）， 否，否，否</li></ul><p>总结： RR下，事务在第一个Read操作时，会建立read-view RC下，事务在每次Read操作时，都会建立read-view</p><h2 id="事务隔离的实现" tabindex="-1"><a class="header-anchor" href="#事务隔离的实现"><span>事务隔离的实现</span></a></h2><p>undo log版本链， readview的 事务set,min_trx_id,max_trx_id,trx_id_list</p>',9)]))}const c=a(s,[["render",r]]),o=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/03-%E4%BA%8B%E5%8A%A1.html","title":"03-事务","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"事务的概念","slug":"事务的概念","link":"#事务的概念","children":[]},{"level":2,"title":"事务隔离的实现","slug":"事务隔离的实现","link":"#事务隔离的实现","children":[]}],"git":{"updatedTime":1746351827000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"a8d5abca5e84b9407cf50b57467ae6a55092ef14","time":1746351827000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql 45讲"}]},"filePathRelative":"guide/mysql/mysql45讲/03-事务.md"}');export{c as comp,o as data};
