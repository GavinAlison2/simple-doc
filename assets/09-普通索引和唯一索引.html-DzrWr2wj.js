import{_ as a,c as l,e as f,o as n}from"./app-DN6Q4pKI.js";const r={};function i(h,e){return n(),l("div",null,e[0]||(e[0]=[f('<h1 id="_09-普通索引和唯一索引" tabindex="-1"><a class="header-anchor" href="#_09-普通索引和唯一索引"><span>09-普通索引和唯一索引</span></a></h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><ol><li>普通索引：索引列的值是唯一的，但可能存在重复的索引值。</li><li>唯一索引：索引列的值是唯一的，不允许有重复的索引值。</li></ol><h2 id="查询过程" tabindex="-1"><a class="header-anchor" href="#查询过程"><span>查询过程</span></a></h2><ol><li>首先，MySQL 会扫描索引树，找到所有符合索引条件的记录。</li><li>如果索引是唯一索引，则 MySQL 可以直接定位到唯一索引值对应的记录。</li><li>如果索引是普通索引，则 MySQL 需要根据索引列的值，在索引树中进行二分查找，定位到所有符合索引条件的记录。</li><li>然后，MySQL 会根据查询条件，对定位到的记录进行过滤。</li><li>最后，MySQL 返回符合查询条件的记录。</li></ol><h2 id="更新过程" tabindex="-1"><a class="header-anchor" href="#更新过程"><span>更新过程</span></a></h2><ol><li>如果索引是唯一索引，则 MySQL 无法直接更新索引值对应的记录。</li><li>如果索引是普通索引，则 MySQL 可以根据索引列的值，在索引树中进行二分查找，定位到所有符合索引条件的记录。</li><li>然后，MySQL 会根据更新条件，对定位到的记录进行更新。</li><li>最后，MySQL 返回更新后的记录。</li></ol><h2 id="change-buffer概念" tabindex="-1"><a class="header-anchor" href="#change-buffer概念"><span>change buffer概念</span></a></h2><p>二级索引的更新操作需要change buffer.</p><p>change buffer 是 MySQL 为了提高更新效率而引入的一种机制。change buffer 是一个内存结构，它在内存中维护一个更新列表，当有更新操作发生时，MySQL 会将更新操作记录在 change buffer 中，而不是直接将更新操作写入磁盘。</p><p>当内存中的 change buffer 占用内存达到一定比例时，MySQL 会将 change buffer 中的更新操作批量写入磁盘。</p><h2 id="change-buffer和-buffer-pool-区别" tabindex="-1"><a class="header-anchor" href="#change-buffer和-buffer-pool-区别"><span>change buffer和 buffer pool 区别</span></a></h2><p>Change Buffer 是在 Buffer Pool 中的。</p><ol><li>change buffer 是在内存中维护的更新列表，buffer pool 是 MySQL 用来缓存数据的内存区域。</li><li>change buffer 仅在内存中，buffer pool 既可以在内存中，也可以在磁盘中。</li><li>change buffer 仅用于维护更新列表，buffer pool 用于缓存数据。</li><li>change buffer 的大小是固定的，buffer pool 的大小可以根据 MySQL 配置进行调整。</li><li>change buffer 仅在内存中，因此速度更快，但是数据丢失风险高。buffer pool 既可以缓存热数据，也可以缓存冷数据。</li><li>change buffer 仅用于维护更新列表，因此对查询的影响最小。buffer pool 用于缓存数据，因此对查询的影响也会有所增加。</li></ol><p>change buffer是持久化数据，在内存中有拷贝，也会写到磁盘上。 当更新数据页时，如数据页在内存中直接更新。如果不在，在不影响数据一致性的前提下，innodb会将更新操作先缓存到change buffer中，当下次查询该数据页时，执行change buffer中与该页相关的操作。该操作称为merge，除了该情况，系统后台线程也会定期merge，数据库正常关闭也会merge。 change buffer可以减少读磁盘，而且数据读入内存会占用buffer pool。</p><p>什么条件下可以使用 change buffer 呢？</p><p>对于唯一索引，更新操作都需要判断操作是否违反唯一约束，所以需要将数据都读入到内存，所以会直接更新内存。 所以只有普通索引会使用change buffer。</p><p>change buffer使用buffer pool里的内存，参数innodb_change_buffer_max_size设置为50时，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><p>当更新记录的目标页不在内存中时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li><li>所以这种情况，唯一索引会导致磁盘大量随机IO的访问（机械硬盘瓶颈）。</li><li>但这种情况不是绝对的，写多读少的场景change buffer记录的变更多，收益越大。常见业务模型账单类、日志类的系统。</li><li>对于写完马上读取的情况，会立即触发merge，反而增加了维护change buffer的成本。</li></ul><p>所以尽量选择普通索引。</p><h3 id="定义与作用" tabindex="-1"><a class="header-anchor" href="#定义与作用"><span>定义与作用</span></a></h3><p>Change buffer 是一种特殊的缓存结构，用于存储对非唯一二级索引页的修改操作。 当数据库执行插入、更新或删除操作时，如果涉及到的非唯一二级索引页不在内存中，InnoDB 不会立即从磁盘读取该页到内存进行修改， 而是先将修改记录在 change buffer 中。这样可以减少磁盘 I/O 操作，提高数据库的性能。</p><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h3><p>写入过程：</p><p>当有针对非唯一二级索引的修改操作时，InnoDB 会首先检查对应的索引页是否在缓冲池中。 如果不在，就将修改记录到 change buffer 中。记录的内容包括修改的类型（插入、更新或删除）以及相关的索引键值和记录指针等信息。</p><p>合并过程：</p><p>在未来的某个时刻，当需要访问该索引页时，InnoDB 会将 change buffer 中针对该页的修改合并到内存中的索引页上。 这个过程称为 change buffer 的合并（merge）操作。 此外，InnoDB 也会在后台定期进行 change buffer 的合并操作，以确保修改最终能持久化到磁盘上的索引文件中。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><p>减少磁盘 I/O：</p><p>通过将对非唯一二级索引的修改先缓存起来，避免了大量的随机磁盘读操作。特别是对于一些写入密集型的工作负载，如电商系统中的订单插入、用户行为日志记录等场景，能够显著提高数据库的写入性能。</p><p>适用场景：</p><p>写入密集型应用：对于那些有大量插入、更新操作的数据库应用，如社交媒体平台的用户动态发布、金融系统的交易记录等，change buffer 能够发挥很好的性能优化作用。</p><p>配置与管理：</p><p>在 MySQL 中，可以通过参数innodb_change_buffer_max_size来配置 change buffer 占用缓冲池的最大比例，默认值是 25%。</p>',35)]))}const p=a(r,[["render",i]]),u=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/09-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95.html","title":"09-普通索引和唯一索引","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"查询过程","slug":"查询过程","link":"#查询过程","children":[]},{"level":2,"title":"更新过程","slug":"更新过程","link":"#更新过程","children":[]},{"level":2,"title":"change buffer概念","slug":"change-buffer概念","link":"#change-buffer概念","children":[]},{"level":2,"title":"change buffer和 buffer pool 区别","slug":"change-buffer和-buffer-pool-区别","link":"#change-buffer和-buffer-pool-区别","children":[{"level":3,"title":"定义与作用","slug":"定义与作用","link":"#定义与作用","children":[]},{"level":3,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[]},{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]}]}],"git":{"updatedTime":1746351827000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"a8d5abca5e84b9407cf50b57467ae6a55092ef14","time":1746351827000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql 45讲"}]},"filePathRelative":"guide/mysql/mysql45讲/09-普通索引和唯一索引.md"}');export{p as comp,u as data};
