import{_ as a,c as n,e as i,o as s}from"./app-DlGl6QFf.js";const l={};function t(r,e){return s(),n("div",null,e[0]||(e[0]=[i(`<h1 id="kafka延迟队列" tabindex="-1"><a class="header-anchor" href="#kafka延迟队列"><span>Kafka延迟队列</span></a></h1><h2 id="延迟队列" tabindex="-1"><a class="header-anchor" href="#延迟队列"><span>延迟队列</span></a></h2><p>Java 的 DelayQueue 是一个支持延迟的队列，可以存储元素并按照指定的时间间隔进行排序。</p><p>Kafka 的延迟队列是基于 Zookeeper 实现的，它可以存储元素并按照指定的时间间隔进行排序。</p><div class="language-markdown line-numbers-mode" data-highlighter="prismjs" data-ext="md"><pre><code><span class="line">生产者---》kafka topic-partition --》 消费者</span>
<span class="line"></span>
<span class="line">消费者基于时间戳进行延迟消费</span>
<span class="line">问题</span>
<span class="line"><span class="token list punctuation">1.</span> 消费者宕机，消息丢失，需要手动维护offset</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="基于时间轮实现延迟队列" tabindex="-1"><a class="header-anchor" href="#基于时间轮实现延迟队列"><span>基于时间轮实现延迟队列</span></a></h3><ol><li>生产者将数据写入到延迟文件中，文件名为时间戳</li><li>生产者有个定时任务，每隔一段时间扫描延迟文件，将时间戳小于当前时间的消息写入到 kafka topic-partition 中</li><li>消费者消费 kafka topic-partition 中的消息，消费者根据消息的时间戳进行延迟消费</li></ol><h3 id="基于-zookeeper-实现延迟队列" tabindex="-1"><a class="header-anchor" href="#基于-zookeeper-实现延迟队列"><span>基于 Zookeeper 实现延迟队列</span></a></h3><ol><li>生产者将数据写入到 kafka topic-partition 中，同时写入到 Zookeeper 中，同时设置过期时间</li><li>消费者消费 kafka topic-partition 中的消息，消费者根据消息的过期时间进行延迟消费</li><li>当消费者宕机，重新启动后，会从 Zookeeper 中获取消费进度，并从相应的位置开始消费</li></ol><h3 id="使用java的delayqueue实现延迟队列" tabindex="-1"><a class="header-anchor" href="#使用java的delayqueue实现延迟队列"><span>使用Java的DelayQueue实现延迟队列</span></a></h3><div class="language-markdown line-numbers-mode" data-highlighter="prismjs" data-ext="md"><pre><code><span class="line"><span class="token list punctuation">1.</span> 生产者由延迟处理线程，将数据写入到延迟队列delayqueue中，另一个线程消费延迟队列delayqueue中的数据，并写入到kafka topic-partition中。</span>
<span class="line"><span class="token list punctuation">2.</span> 消费者消费kafka topic-partition中的消息，消费者根据消息的时间戳进行延迟消费。</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用rocketmq实现延迟队列" tabindex="-1"><a class="header-anchor" href="#使用rocketmq实现延迟队列"><span>使用RocketMQ实现延迟队列</span></a></h3>`,12)]))}const d=a(l,[["render",t]]),o=JSON.parse('{"path":"/guide/mq/kafka/1-kafka%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.html","title":"Kafka延迟队列","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"延迟队列","slug":"延迟队列","link":"#延迟队列","children":[{"level":3,"title":"基于时间轮实现延迟队列","slug":"基于时间轮实现延迟队列","link":"#基于时间轮实现延迟队列","children":[]},{"level":3,"title":"基于 Zookeeper 实现延迟队列","slug":"基于-zookeeper-实现延迟队列","link":"#基于-zookeeper-实现延迟队列","children":[]},{"level":3,"title":"使用Java的DelayQueue实现延迟队列","slug":"使用java的delayqueue实现延迟队列","link":"#使用java的delayqueue实现延迟队列","children":[]},{"level":3,"title":"使用RocketMQ实现延迟队列","slug":"使用rocketmq实现延迟队列","link":"#使用rocketmq实现延迟队列","children":[]}]}],"git":{"updatedTime":1746293673000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"e5945ebdbc3e2b976f95add711e081bdd86f39b7","time":1746293673000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"}]},"filePathRelative":"guide/mq/kafka/1-kafka延迟队列.md"}');export{d as comp,o as data};
