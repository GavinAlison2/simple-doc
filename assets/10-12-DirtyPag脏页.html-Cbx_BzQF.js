import{_ as s,c as e,e as n,o as l}from"./app-DzmgiGLk.js";const p={};function t(r,a){return l(),e("div",null,a[0]||(a[0]=[n(`<h1 id="_10-12-dirtypag脏页" tabindex="-1"><a class="header-anchor" href="#_10-12-dirtypag脏页"><span>10-12-DirtyPag脏页</span></a></h1><h2 id="_10-mysql为什么有时候会选错索引" tabindex="-1"><a class="header-anchor" href="#_10-mysql为什么有时候会选错索引"><span>10 | MySQL为什么有时候会选错索引？</span></a></h2><p>平常不断地删除历史数据和新增数据的场景，mysql有可能会选错索引。</p><h3 id="优化器的逻辑" tabindex="-1"><a class="header-anchor" href="#优化器的逻辑"><span>优化器的逻辑</span></a></h3><p>优化器选择索引的目的就是选择一个扫描行数最少的方案。行数越少，磁盘读取越少。 扫描行数不是唯一标准，优化器还会结合是否使用临时表，是否排序等因素。</p><p>扫描行数怎么判断？</p><p>真正执行语句之前，mysql不知道具体有多少条，只能根据统计信息估算。</p><p>这个统计信息就是索引的“区分度”。索引上不同值越多，区分度越好。而一个索引上不同值的个数称为“基数”。</p><p>使用show index可以查看。下图中，每行三个字段值都是一样的，但在统计信息中，基数值都不准确。</p><h3 id="mysql怎么得到索引的基数" tabindex="-1"><a class="header-anchor" href="#mysql怎么得到索引的基数"><span>mysql怎么得到索引的基数？</span></a></h3><p>mysql采用采样统计，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。 参数 innodb_stats_persistent有两种不同的模式</p><ul><li>设置为 on 的时候，表示统计信息会持久化存储。默认 N 是 20，M 是 10。</li><li>设置为 off 的时候，表示统计信息只存储在内存中。默认 N 是 8，M 是 16。</li></ul><p>如果统计信息不对，可以使用analyze table t 命令重新统计。</p><p>索引选择异常和处理</p><ul><li>force index 强行选择一个索引</li><li>修改语句，引导 MySQL 使用我们期望的索引</li><li>新建索引，或者删除误用的索引</li></ul><p>这章老师举了几个例子，就不写了。sql太慢就用explain看看，有可能就是索引选错了。</p><h2 id="_11-怎么给字符串字段加索引" tabindex="-1"><a class="header-anchor" href="#_11-怎么给字符串字段加索引"><span>11 | 怎么给字符串字段加索引</span></a></h2><p>mysql支持前缀索引，可以以字符串一部分作为索引。默认包含整个字符串。</p><p><code>alter table t index idx(a(6));</code></p><p>使用前缀索引虽然可以减少存储空间，但有可能会增加回表次数。</p><p>建前缀索引前可以使用下面的sql统计一下重复数：</p><p><code>select count(distinct left(a,字符长度));</code></p><p>并且前缀索引会影响覆盖索引。</p><p>其他方式</p><ol><li>倒序存储 由于身份证前面的地区码都是相同的，所以存储身份证时，可以将它倒过来存。身份证后6位作为前缀索引有一定的区分度。</li></ol><p><code>select field_list from t where id_card = reverse(&#39;input_id_card_string&#39;);</code></p><ol start="2"><li>使用hash字段</li></ol><p>可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。 插入新数据，使用crc32()得到该字段填入。 查询语句如下：</p><p><code>select field_list from t where id_card_crc=crc32(&#39;input_id_card_string&#39;) and id_card=&#39;input_id_card_string&#39;；</code></p><p>另外，如果前缀后缀都重复，可以考虑去掉前缀后缀，只存中间一部分数据。</p><h2 id="_12-为什么我的mysql会有脏页" tabindex="-1"><a class="header-anchor" href="#_12-为什么我的mysql会有脏页"><span>12 | 为什么我的MySQL会有脏页</span></a></h2><p>脏页的概念就不记了。 MySQL 偶尔慢一下的那个瞬间，可能在刷脏页（flush）。</p><p>什么时候会触发刷脏？</p><ol><li>innodb的redo log写满了，这时候系统会停止所有更新。把checkpoint 往前推进。</li><li>buffer pool内存不足，此时需要淘汰一些数据页，有可能会淘汰脏页，就要先把脏页刷到磁盘。</li></ol><p>刷脏页一定会写盘，就保证了每个数据页有两种状态： a. 内存里的一定是正确数据。 b. 内存里没有，磁盘上的一定是正确数据。</p><ol start="3"><li>mysql认为系统空闲时，会刷盘。当然系统繁忙时，也会见缝插针刷盘。</li><li>mysql正常关闭。</li></ol><p>InnoDB 刷脏页的控制策略</p><p>告诉 InnoDB 所在主机的 IO 能力，正确地设置innodb_io_capacity 参数，使用fio工具统计：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line">fio <span class="token parameter variable">-filename</span><span class="token operator">=</span><span class="token variable">$filename</span> <span class="token parameter variable">-direct</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-iodepth</span> <span class="token number">1</span> <span class="token parameter variable">-thread</span> <span class="token parameter variable">-rw</span><span class="token operator">=</span>randrw <span class="token parameter variable">-ioengine</span><span class="token operator">=</span>psync <span class="token parameter variable">-bs</span><span class="token operator">=</span>16k <span class="token parameter variable">-size</span><span class="token operator">=</span>500M <span class="token parameter variable">-numjobs</span><span class="token operator">=</span><span class="token number">10</span> <span class="token parameter variable">-runtime</span><span class="token operator">=</span><span class="token number">10</span> <span class="token parameter variable">-group_reporting</span> <span class="token parameter variable">-name</span><span class="token operator">=</span>mytest </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>innodb_max_dirty_pages_pct是脏页比例上限，默认值是 75%。 平时要多关注脏页比例，不要让它经常接近 75%。 脏页比例是通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">select</span> VARIABLE_VALUE <span class="token keyword">into</span> <span class="token variable">@a</span> <span class="token keyword">from</span> global_status <span class="token keyword">where</span> VARIABLE_NAME <span class="token operator">=</span> <span class="token string">&#39;Innodb_buffer_pool_pages_dirty&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">select</span> VARIABLE_VALUE <span class="token keyword">into</span> <span class="token variable">@b</span> <span class="token keyword">from</span> global_status <span class="token keyword">where</span> VARIABLE_NAME <span class="token operator">=</span> <span class="token string">&#39;Innodb_buffer_pool_pages_total&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">select</span> <span class="token variable">@a</span><span class="token operator">/</span><span class="token variable">@b</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外还有一个策略，当刷脏页时，该页边上也是脏页，也会把边上的脏页一起刷掉。而且该逻辑会一直蔓延。 innodb_flush_neighbors 参数就是来控制该行为的，值为1会有上述机制，0则不会。 机械硬盘可能会有不错的效果，但ssd建议设置为0。 并且mysql 8.0 innodb_flush_neighbors 默认为0。</p>`,42)]))}const o=s(p,[["render",t]]),c=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/10-12-DirtyPag%E8%84%8F%E9%A1%B5.html","title":"10-12-DirtyPag脏页","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"10 | MySQL为什么有时候会选错索引？","slug":"_10-mysql为什么有时候会选错索引","link":"#_10-mysql为什么有时候会选错索引","children":[{"level":3,"title":"优化器的逻辑","slug":"优化器的逻辑","link":"#优化器的逻辑","children":[]},{"level":3,"title":"mysql怎么得到索引的基数？","slug":"mysql怎么得到索引的基数","link":"#mysql怎么得到索引的基数","children":[]}]},{"level":2,"title":"11 | 怎么给字符串字段加索引","slug":"_11-怎么给字符串字段加索引","link":"#_11-怎么给字符串字段加索引","children":[]},{"level":2,"title":"12 | 为什么我的MySQL会有脏页","slug":"_12-为什么我的mysql会有脏页","link":"#_12-为什么我的mysql会有脏页","children":[]}],"git":{"updatedTime":1746351827000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"a8d5abca5e84b9407cf50b57467ae6a55092ef14","time":1746351827000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql 45讲"}]},"filePathRelative":"guide/mysql/mysql45讲/10-12-DirtyPag脏页.md"}');export{o as comp,c as data};
