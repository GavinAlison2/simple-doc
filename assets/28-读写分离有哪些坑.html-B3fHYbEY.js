import{_ as l,c as i,e as s,o as a}from"./app-DlGl6QFf.js";const t="/simple-doc/assets/proxy-D0iNc5ww.png",p="/simple-doc/assets/slave-DRqfwm6a.png",o="/simple-doc/assets/slave2-xh9DjoT-.png",c={};function n(r,e){return a(),i("div",null,e[0]||(e[0]=[s('<h1 id="读写分离有哪些坑" tabindex="-1"><a class="header-anchor" href="#读写分离有哪些坑"><span>读写分离有哪些坑</span></a></h1><p>上节的主从是由客户端直联的。 另一种架构proxy：</p><p><img src="'+t+'" alt="proxy"></p><p>代理架构，客户端不会感知数据库端的细节，只需对接代理。但加一层代理，链路会变长，而且代理也需要高可用架构。 不管是哪种架构，主备都存在延迟。</p><h2 id="强制走主库方案" tabindex="-1"><a class="header-anchor" href="#强制走主库方案"><span>强制走主库方案</span></a></h2><p>对于一些需要拿到实时结果的请求，分发到主库上。但对一些都需要实时结果的金融业务，就需要放弃读写分离。</p><h2 id="sleep方案" tabindex="-1"><a class="header-anchor" href="#sleep方案"><span>sleep方案</span></a></h2><p>延迟几秒再去读从库，但超过这个时间的同步还是拿不到最新的数据。</p><h2 id="判断主备无延迟方案" tabindex="-1"><a class="header-anchor" href="#判断主备无延迟方案"><span>判断主备无延迟方案</span></a></h2><ol><li>判断show slave status 结果里的 seconds_behind_master 参数的值是否等于0，但该值精度为秒。</li><li>对比位点确保主备无延迟，Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。</li><li>对比 GTID 集合确保主备无延迟，Retrieved_Gtid_Set、Executed_Gtid_Set是否相同。</li></ol><p><img src="'+p+'" alt="slave"></p><p>上述方案，只会判断从库已经收到的事务，是否执行完，但对于一些主库已执行，但从库还没收到的情况，还是存在主备延迟。</p><h2 id="配合-semi-sync" tabindex="-1"><a class="header-anchor" href="#配合-semi-sync"><span>配合 semi-sync</span></a></h2><p>要解决这个问题，就要引入半同步复制，也就是semi-sync replication。</p><ul><li>事务提交的时候，主库把 binlog 发给从库；</li><li>从库收到 binlog 以后，发回给主库一个 ack，表示收收到；</li><li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li></ul><p>但一主多从的情况主库只要收到一个从库返回ack，就会提交事务。所以在查询其他从库时，可能还是会存在主备延迟。 其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p><h2 id="等主库位点方案" tabindex="-1"><a class="header-anchor" href="#等主库位点方案"><span>等主库位点方案</span></a></h2><p>实际上并不需要等待主备完全同步，其实从库查询trx1时只需要该事务完成就可以返回：</p><p><img src="'+o+'" alt="slave2"></p><p>首先看一条sql</p><p><code>select master_pos_wait(file, pos[, timeout]);</code></p><ol><li>它是在从库执行的；</li><li>参数 file 和 pos 指的是主库上的文件名和位置；</li><li>timeout 可选，设置为正整数 N 表示这个函数最多等待N 秒。</li></ol><p>这个会返回一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。除了正常返回之外，还会返回：</p><ol><li>如果执行期间，备库同步线程发生异常，则返回 NULL；</li><li>如果等待超过 N 秒，就返回 -1；</li><li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</li></ol><p>所以可以这么判断：</p><ol><li>trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的File 和 Position；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select master_pos_wait(File, Position, 1)；</li><li>如果返回值是 &gt;=0 的正整数，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><p>所以可能存在将流量打到主库的情况，所以需要做好主库限流策略。</p><h2 id="gtid-方案" tabindex="-1"><a class="header-anchor" href="#gtid-方案"><span>GTID 方案</span></a></h2><p><code>select wait_for_executed_gtid_set(gtid_set, 1);</code></p><ul><li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li><li>超时返回 1。</li></ul><p>MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p><ul><li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li><li>如果返回值是 0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ul>',32)]))}const h=l(c,[["render",n]]),_=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/28-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91.html","title":"读写分离有哪些坑","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"强制走主库方案","slug":"强制走主库方案","link":"#强制走主库方案","children":[]},{"level":2,"title":"sleep方案","slug":"sleep方案","link":"#sleep方案","children":[]},{"level":2,"title":"判断主备无延迟方案","slug":"判断主备无延迟方案","link":"#判断主备无延迟方案","children":[]},{"level":2,"title":"配合 semi-sync","slug":"配合-semi-sync","link":"#配合-semi-sync","children":[]},{"level":2,"title":"等主库位点方案","slug":"等主库位点方案","link":"#等主库位点方案","children":[]},{"level":2,"title":"GTID 方案","slug":"gtid-方案","link":"#gtid-方案","children":[]}],"git":{"updatedTime":1746338840000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"782aea8180789c4b3dd4cd07cb76b397e115be73","time":1746338840000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"}]},"filePathRelative":"guide/mysql/mysql45讲/28-读写分离有哪些坑.md"}');export{h as comp,_ as data};
