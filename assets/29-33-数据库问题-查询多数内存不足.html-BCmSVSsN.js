import{_ as s,c as a,e,o as p}from"./app-DlGl6QFf.js";const l="/simple-doc/assets/deadline-BJxkq73p.png",t="/simple-doc/assets/wait_lock-BocY3mND.png",o="/simple-doc/assets/wait_lock2-DESh4DvZ.png",c="/simple-doc/assets/wait_lock3-D_udzB5t.png",i="/simple-doc/assets/wait_lock4-DrUbfzDe.png",r="/simple-doc/assets/query-server-C4JMBsN4.png",u="/simple-doc/assets/lru-Bw7Pgx0t.png",d={};function k(h,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="_29-33" tabindex="-1"><a class="header-anchor" href="#_29-33"><span>29-33</span></a></h1><h2 id="_29-如何判断一个数据库是不是出问题" tabindex="-1"><a class="header-anchor" href="#_29-如何判断一个数据库是不是出问题"><span>29 | 如何判断一个数据库是不是出问题</span></a></h2><h3 id="select-1-判断" tabindex="-1"><a class="header-anchor" href="#select-1-判断"><span>select 1 判断</span></a></h3><p>当前并发查询数超过innodb_thread_concurrency时， select 1会返回，但执行查询命令时会等待。</p><p>该参数默认值是0，表示不限制并发查询数，建议把 innodb_thread_concurrency 设置为 64~128 之间的值。不是并发连接数。</p><h3 id="查表判断" tabindex="-1"><a class="header-anchor" href="#查表判断"><span>查表判断</span></a></h3><p>在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行：</p><p><code>select * from mysql.health_check</code></p><p>但有其他一个问题，更新事务要写 binlog，binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p><h3 id="更新判断" tabindex="-1"><a class="header-anchor" href="#更新判断"><span>更新判断</span></a></h3><p>常见做法是放一个 timestamp 字段，用来表示最后一次执行检测的时间。但备库不能写同一行，所以需要使用多行，id为server_id。</p><p><code>update mysql.health_check set t_modified=now();</code></p><p>但有可能，机器的I/O已经100%，但刚好健康检查的sql拿到了资源，成功返回了。</p><h3 id="内部统计" tabindex="-1"><a class="header-anchor" href="#内部统计"><span>内部统计</span></a></h3><p>关于磁盘利用率100%的问题。 MySQL 5.6 版本以后提供的 performance_schema 库，就在 file_summary_by_event_name 表里统计了每次 IO 请求的时间。</p><p>老师比较倾向的方案，是优先考虑 update 系统表，，然后再配合增加检测 performance_schema的信息。</p><h2 id="_30-答疑文章-二-用动态的观点看加锁" tabindex="-1"><a class="header-anchor" href="#_30-答疑文章-二-用动态的观点看加锁"><span>30 | 答疑文章（二）：用动态的观点看加锁</span></a></h2><p>先复习一下老师在 21 | 为什么我只改一行的语句，锁这么多？ 文章中提到了两个“原则”、两个“优化”和一个“bug”。 该文章基于下面的表结构：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>t<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>c<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>d<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>c<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>c<span class="token punctuation">\`</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="不等号条件里的等值查询" tabindex="-1"><a class="header-anchor" href="#不等号条件里的等值查询"><span>不等号条件里的等值查询</span></a></h3><p>等值查询和“遍历”有什么区别？为什么我们文章的例子里面，where 条件是不等号，这个过程里也有等值查询？</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">begin</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">&gt;</span><span class="token number">9</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span><span class="token number">12</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">desc</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的规则可以知道加锁区间(0,5]、(5,10] 和 (10, 15)。</p><ul><li>首先这个查询语句的语义是 order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个 id&lt;12 的值”。</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找id=12 的这个值，只是最终没找到，但找到了(10,15) 这个间隙。</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，所以会加一个 next-key lock (0,5]。</li></ul><p>也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。</p><h3 id="等值查询的过程" tabindex="-1"><a class="header-anchor" href="#等值查询的过程"><span>等值查询的过程</span></a></h3><p>下面这个语句的加锁范围是什么？</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">begin</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> c <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">explain</span> <span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> c <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token operator">-</span>id<span class="token punctuation">,</span>select_type<span class="token punctuation">,</span> table_partition<span class="token punctuation">,</span><span class="token keyword">type</span><span class="token punctuation">,</span> possible_keys<span class="token punctuation">,</span> key_len<span class="token punctuation">,</span> ref<span class="token punctuation">,</span> <span class="token keyword">rows</span><span class="token punctuation">,</span> filtered<span class="token punctuation">,</span> extra</span>
<span class="line"><span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">simple</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> range<span class="token punctuation">,</span> c<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">100.00</span> <span class="token punctuation">,</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">,</span> <span class="token keyword">Using</span> <span class="token keyword">index</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>in 语句使用了索引 c 并且 rows=3，说明这三个值都是通过 B+ 树搜索定位的。</li><li>在查找 c=5 的时候，先锁住了 (0,5]。但是因为 c 不是唯一索引，为了确认还有没有别的记录 c=5，就要向右遍历，找到 c=10 才确认没有了，这个过程满足优化 2，所以加了间隙锁 (5,10)。</li><li>同样的，执行 c=10 这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行 c=20 这个逻辑的时候，加锁的范围是 (15,20] 和 (20,25)。</li><li>这条语句在索引 c 上加的三个记录锁的顺序是：先加 c=5 的记录锁，再加 c=10 的记录锁，最后加 c=20 的记录锁。</li></ul><h3 id="怎么看死锁" tabindex="-1"><a class="header-anchor" href="#怎么看死锁"><span>怎么看死锁？</span></a></h3><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> c <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> c <span class="token keyword">desc</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当执行上述命令时，加锁顺序和会之前那句相反，会产生死锁。</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="`+l+'" alt="deadline"></p><p>三部分：</p><ul><li>TRANSACTION，是第一个事务的信息；</li><li>TRANSACTION，是第二个事务的信息；</li><li>WE ROLL BACK TRANSACTION (1)，最终回滚了第一个事务。</li></ul><p>得到的结论：</p><ul><li>由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；</li><li>在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以 InnoDB 选择了回滚成本更小的 lockin share mode 语句，来回滚。</li></ul><h3 id="怎么看锁等待" tabindex="-1"><a class="header-anchor" href="#怎么看锁等待"><span>怎么看锁等待？</span></a></h3><p><img src="'+t+'" alt="wait_lock"></p><p>session A 并没有锁住 c=10 这个记录，delete之后不能insert。</p><p><img src="'+o+'" alt="wait_lock2"></p><p>由于 delete 操作把 id=10 这一行删掉了，原来的两个间隙 (5,10)、(10,15）变成了一个 (5,15)。</p><p>update 的例子</p><p><img src="'+c+'" alt="wait_lock3"></p><p>虽然session A 的加锁范围是索引 c 上的 (5,10]、(10,15]、(15,20]、(20,25] 和 (25,supremum]，但update后加锁范围变成了下图：</p><p><img src="'+i+'" alt="wait_lock4"></p><h2 id="_31-误删数据后除了跑路-还能怎么办" tabindex="-1"><a class="header-anchor" href="#_31-误删数据后除了跑路-还能怎么办"><span>31 | 误删数据后除了跑路，还能怎么办？</span></a></h2><p>千万不能误删</p><h3 id="误删行" tabindex="-1"><a class="header-anchor" href="#误删行"><span>误删行</span></a></h3><p>binlog_format=row 和 binlog_row_image=FULL 可以使用Flashback回放。 不建议直接在主库使用，应该在备库执行，然后再将确认过的临时库的数据，恢复回主库。</p><h3 id="误删库-表" tabindex="-1"><a class="header-anchor" href="#误删库-表"><span>误删库 / 表</span></a></h3><p>取全量备份，和全量备份时间点之后的binlog恢复。但mysqlbinlog不够快。 一个加速的方法，将全量备份恢复的临时实例，设置为线上备库的从库。</p><h3 id="延迟复制备库" tabindex="-1"><a class="header-anchor" href="#延迟复制备库"><span>延迟复制备库</span></a></h3><p>MySQL 5.6 版本引入，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有N 秒的延迟。</p><h2 id="_32-为什么还有kill不掉的语句" tabindex="-1"><a class="header-anchor" href="#_32-为什么还有kill不掉的语句"><span>32 | 为什么还有kill不掉的语句</span></a></h2><p>kill query + 线程 id：表示终止这个线程中正在执行的语句；</p><p>kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接，如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</p><p>mysql kill命令不是直接终止线程。</p><ul><li>把 session 的运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；</li><li>给 session 的执行线程发一个信号。有些session 由于锁在等待，信号让session 退出等待来处理THD::KILL_QUERY 状态。</li></ul><p>mysql处理过程中有许多埋点，这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑。</p><p>如果碰到一个被 killed 的事务一直处于回滚状态，尽量不要重启，因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。如果这个语句可能会占用别的锁，或者由于占用 IO 资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。避免大事务</p><h2 id="_33-我查这么多数据-会不会把数据库内存打爆" tabindex="-1"><a class="header-anchor" href="#_33-我查这么多数据-会不会把数据库内存打爆"><span>33-我查这么多数据，会不会把数据库内存打爆</span></a></h2><h3 id="全表扫描对-server-层的影响" tabindex="-1"><a class="header-anchor" href="#全表扫描对-server-层的影响"><span>全表扫描对 server 层的影响</span></a></h3><p><img src="'+r+'" alt="query-server"></p><ul><li>net_buffer由参数 net_buffer_length 定义的，默认是 16k。</li><li>mysql是遍读遍发的，所以当net_buffer写满的时候就需要等待。使用show processlist可以看到state=“Sending to client”。</li><li>mysql还要一个state=“Sending data”，它的意思只是“正在执行”。</li></ul><h3 id="全表扫描对-innodb-的影响" tabindex="-1"><a class="header-anchor" href="#全表扫描对-innodb-的影响"><span>全表扫描对 InnoDB 的影响</span></a></h3><p>介绍 WAL 机制时，分析了Buffer Pool 加速更新的作用。 Buffer Pool 还有一个更重要的作用，就是加速查询。 执行 show engine innodb status可以查看一个系统当前的 BP 命中率。</p><p>InnoDB Buffer Pool 的大小是由参数 innodb_buffer_pool_size 确定的，一般建议设置成可用物理内存的 60%~80%。</p><p>InnoDB 内存管理用的是最近最少使用 (LRU) 算法，这个算法的核心就是淘汰最久未使用的数据。</p><p>如果在查询历史数据使用这个算法，会导致很多请求会从磁盘读取数据。所以mysql对LRU算法进行了改进。</p><p><img src="'+u+'" alt="lru"></p><p>在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。</p><ol><li>访问数据页P3，在young区所以把它移到链表同步。</li><li>如果访问不存在的数据，则把链表尾部数据淘汰，但把新数据页Px放在LRU_old处。</li><li>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：</li><li>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；</li><li>如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。</li></ol><p>1s由参数 innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒。</p>',75)]))}const b=s(d,[["render",k]]),_=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/29-33-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98-%E6%9F%A5%E8%AF%A2%E5%A4%9A%E6%95%B0%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3.html","title":"29-33","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"29 | 如何判断一个数据库是不是出问题","slug":"_29-如何判断一个数据库是不是出问题","link":"#_29-如何判断一个数据库是不是出问题","children":[{"level":3,"title":"select 1 判断","slug":"select-1-判断","link":"#select-1-判断","children":[]},{"level":3,"title":"查表判断","slug":"查表判断","link":"#查表判断","children":[]},{"level":3,"title":"更新判断","slug":"更新判断","link":"#更新判断","children":[]},{"level":3,"title":"内部统计","slug":"内部统计","link":"#内部统计","children":[]}]},{"level":2,"title":"30 | 答疑文章（二）：用动态的观点看加锁","slug":"_30-答疑文章-二-用动态的观点看加锁","link":"#_30-答疑文章-二-用动态的观点看加锁","children":[{"level":3,"title":"不等号条件里的等值查询","slug":"不等号条件里的等值查询","link":"#不等号条件里的等值查询","children":[]},{"level":3,"title":"等值查询的过程","slug":"等值查询的过程","link":"#等值查询的过程","children":[]},{"level":3,"title":"怎么看死锁？","slug":"怎么看死锁","link":"#怎么看死锁","children":[]},{"level":3,"title":"怎么看锁等待？","slug":"怎么看锁等待","link":"#怎么看锁等待","children":[]}]},{"level":2,"title":"31 | 误删数据后除了跑路，还能怎么办？","slug":"_31-误删数据后除了跑路-还能怎么办","link":"#_31-误删数据后除了跑路-还能怎么办","children":[{"level":3,"title":"误删行","slug":"误删行","link":"#误删行","children":[]},{"level":3,"title":"误删库 / 表","slug":"误删库-表","link":"#误删库-表","children":[]},{"level":3,"title":"延迟复制备库","slug":"延迟复制备库","link":"#延迟复制备库","children":[]}]},{"level":2,"title":"32 | 为什么还有kill不掉的语句","slug":"_32-为什么还有kill不掉的语句","link":"#_32-为什么还有kill不掉的语句","children":[]},{"level":2,"title":"33-我查这么多数据，会不会把数据库内存打爆","slug":"_33-我查这么多数据-会不会把数据库内存打爆","link":"#_33-我查这么多数据-会不会把数据库内存打爆","children":[{"level":3,"title":"全表扫描对 server 层的影响","slug":"全表扫描对-server-层的影响","link":"#全表扫描对-server-层的影响","children":[]},{"level":3,"title":"全表扫描对 InnoDB 的影响","slug":"全表扫描对-innodb-的影响","link":"#全表扫描对-innodb-的影响","children":[]}]}],"git":{"updatedTime":1746338840000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"782aea8180789c4b3dd4cd07cb76b397e115be73","time":1746338840000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"}]},"filePathRelative":"guide/mysql/mysql45讲/29-33-数据库问题-查询多数内存不足.md"}');export{b as comp,_ as data};
