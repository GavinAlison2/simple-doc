import{_ as s,c as a,e,o as p}from"./app-DN6Q4pKI.js";const o="/simple-doc/assets/join1-D2HiO0QD.png",l="/simple-doc/assets/BNL-Join-D8lSG0VG.png",t={};function i(c,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="到底可不可以使用join" tabindex="-1"><a class="header-anchor" href="#到底可不可以使用join"><span>到底可不可以使用join？</span></a></h1><p>数据准备</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>t2<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>a<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>b<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>a<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>a<span class="token punctuation">\`</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">drop</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">create</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">begin</span></span>
<span class="line">  <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">do</span></span>
<span class="line">    <span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">delimiter</span> <span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">call</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> t1 <span class="token operator">like</span> t2<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> id<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="index-nested-loop-join" tabindex="-1"><a class="header-anchor" href="#index-nested-loop-join"><span>Index Nested-loop join</span></a></h2><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="index-nested-loop-join-1" tabindex="-1"><a class="header-anchor" href="#index-nested-loop-join-1"><span>Index Nested-Loop Join</span></a></h2><p>t1 是驱动表，t2 是被驱动表。t1 全表扫描，t2 索引树扫描。</p><p>t1 是驱动表，t2 是被驱动表。</p><p><img src="`+o+'" alt="join1"></p><ul><li>从表 t1 中读入一行数据 R；</li><li>从数据行R中，取出a字段到表t2里去查找。由于t2表的a字段有索引，所以是通过索引进行查找，先在索引树上找到对应的值，然后获取到对应的主键id，再根据主键id回表查询获取完整的行数据。</li><li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分。</li><li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束</li></ul><p>t1只有100行，所有一共扫描100行。</p><p>如果执行select * from t1，再执行select * from t2 where a=$R.a。虽然都可以走索引，也只扫描100行。但需要执行101行sql。</p><p>如果可以走索引：</p><ul><li>使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好；</li><li>如果使用 join 语句的话，需要让小表做驱动表。</li></ul><p>性能分析</p><p>在上述流程中，对驱动表t1做了全表扫描。 假设t1表有N行数据，那么扫描t1表需要扫描N行。 而对于t1中的每一行数据，根据a字段去表t2查找时，走的是树搜索过程。 假设t2表有M行数据，每次搜索一棵树的近似复杂度是以 2 为底的M的对数，记为<code>log₂M</code>。 因为要先搜索索引a，再搜索主键索引，所以在被驱动表上查一行的时间复杂度是<code>2*log₂M</code>。 因此，整个执行过程的近似复杂度是 <code>N + N*2*log₂M</code>。 由此可见，N对扫描行数的影响更大，所以应该让小表来做驱动表，以减少总的扫描行数，提高性能。</p><p>适用场景</p><p>Index Nested - Loop Join 适用于被驱动表连接字段上有索引的情况。当连接条件中的字段在被驱动表上有索引时，MySQL 优化器通常会选择使用 Index Nested - Loop Join 算法来执行连接操作，以提高查询性能。</p><p>NLJ 算法的优点是简单、易于理解，缺点是性能不如 Hash Join 算法。因此，如果连接条件中的字段在被驱动表上没有索引，则 MySQL 会选择 Hash Join 算法来执行连接操作。</p><h2 id="simple-nested-loop-join" tabindex="-1"><a class="header-anchor" href="#simple-nested-loop-join"><span>Simple Nested-Loop join</span></a></h2><p>当被驱动表连接字段上没有索引时，</p><p>就会使用 Simple Nested -Loop Join 算法，即每次从驱动表读取一行数据，都要到被驱动表进行全表扫描来找出匹配数据，性能较差。例如，若t1有 100 行数据，t2有 1000 行数据，使用 Simple Nested-Loop Join 算法就需要扫描t2表 100 次，总共扫描 100×1000 = 10 万行。</p><h2 id="block-nested-loop-join" tabindex="-1"><a class="header-anchor" href="#block-nested-loop-join"><span>Block Nested - Loop Join</span></a></h2><p>MySQL 没有使用 Simple Nested-Loop Join 算法，而是使用了“Block Nested-Loop Join”算法，简称BNL。</p><p>是对 Simple Nested - Loop Join 的优化，针对被驱动表连接列上没索引的情况。该算法开辟了一块join_buffer内存，将驱动表的数据读入其中，然后扫描被驱动表，将被驱动表中的每一行与join_buffer中的数据进行匹配，减少了被驱动表的扫描次数。</p><p><img src="'+l+`" alt="BNL-Join"></p><ol><li>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</li><li>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</li></ol><p>虽然都会扫描100*1000行，但BNL是内存判断，所以会快一点。</p><p>小结</p><ol><li>如果可以使用被驱动表的索引，join 语句还是有其优势的；</li><li>不能使用被驱动表的索引，只能使用 BNL 算法，这样的语句就尽量不要使用；</li><li>在使用 join 的时候，应该让小表做驱动表。</li></ol><p>如果被驱动表是个大表，会把冷数据的page加入到buffer pool，并且BNL要扫描多次，两次扫描的时间可能会超过1秒，使上节提到的分代LRU优化失效，把热点数据从buffer pool中淘汰掉，影响正常业务的查询效率。</p><h2 id="code" tabindex="-1"><a class="header-anchor" href="#code"><span>code</span></a></h2><h3 id="simple-nested-loop-join-1" tabindex="-1"><a class="header-anchor" href="#simple-nested-loop-join-1"><span>simple nested-loop join</span></a></h3><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">for</span> row_A <span class="token keyword">in</span> table_A<span class="token punctuation">:</span></span>
<span class="line">    <span class="token keyword">for</span> row_B <span class="token keyword">in</span> table_B<span class="token punctuation">:</span></span>
<span class="line">        <span class="token keyword">if</span> row_A<span class="token punctuation">.</span>col <span class="token operator">==</span> row_B<span class="token punctuation">.</span>col<span class="token punctuation">:</span></span>
<span class="line">            output<span class="token punctuation">(</span>row_A<span class="token punctuation">,</span> row_B<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>特别是当表的规模较大时，需要进行大量的比较操作。其时间复杂度为 <code>O(n∗m)</code>，这里的 <code>n</code> 和 <code>m</code> 分别代表两个表的行数。</p><h3 id="block-nested-loop-join-1" tabindex="-1"><a class="header-anchor" href="#block-nested-loop-join-1"><span>Block Nested-Loop Join</span></a></h3><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line">join_buffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line"><span class="token keyword">for</span> row_A <span class="token keyword">in</span> table_A<span class="token punctuation">:</span></span>
<span class="line">    join_buffer<span class="token punctuation">.</span>append<span class="token punctuation">(</span>row_A<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">for</span> row_B <span class="token keyword">in</span> join_buffer<span class="token punctuation">:</span></span>
<span class="line">        <span class="token keyword">if</span> row_A<span class="token punctuation">.</span>col <span class="token operator">==</span> row_B<span class="token punctuation">.</span>col<span class="token punctuation">:</span></span>
<span class="line">            output<span class="token punctuation">(</span>row_A<span class="token punctuation">,</span> row_B<span class="token punctuation">)</span></span>
<span class="line">    join_buffer<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>row_A<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="两者区别" tabindex="-1"><a class="header-anchor" href="#两者区别"><span>两者区别：</span></a></h3><ul><li>内存使用：Simple Nested-Loop Join 没有利用额外的内存来优化连接操作，而 Block Nested-Loop Join 借助 join - buffer 来缓存驱动表的多行数据，减少了被驱动表的扫描次数。</li><li>扫描次数：Simple Nested-Loop Join 对被驱动表的扫描次数和驱动表的行数相同，也就是每处理驱动表的一行，就需要扫描一次被驱动表。而 Block Nested-Loop Join 把驱动表按块加载到 join-buffer 中，被驱动表的扫描次数和驱动表的块数相等，这就大大减少了扫描次数。</li><li>效率：由于 Block Nested-Loop Join 减少了被驱动表的扫描次数，所以在大多数情况下，其效率要高于 Simple Nested-Loop Join。</li></ul><h3 id="关于全表扫描" tabindex="-1"><a class="header-anchor" href="#关于全表扫描"><span>关于全表扫描</span></a></h3><p>虽然 Block Nested-Loop Join 仍然需要对表进行全扫描，但通过 join-buffer 减少了扫描的次数，从而降低了 I/O 开销。 特别是在磁盘 I/O 成为性能瓶颈时，这种优化能显著提升连接操作的效率。 例如，假设驱动表有 1000 行，被驱动表有 100 行，Simple Nested-Loop Join 需要对被驱动表进行 1000 次扫描， 而 Block Nested-Loop Join 若每次将驱动表的 100 行加载到 join-buffer 中，那么只需要对被驱动表进行 10 次扫描。</p>`,41)]))}const r=s(t,[["render",i]]),u=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/34%20-%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join.html","title":"到底可不可以使用join？","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Index Nested-loop join","slug":"index-nested-loop-join","link":"#index-nested-loop-join","children":[]},{"level":2,"title":"Index Nested-Loop Join","slug":"index-nested-loop-join-1","link":"#index-nested-loop-join-1","children":[]},{"level":2,"title":"Simple Nested-Loop join","slug":"simple-nested-loop-join","link":"#simple-nested-loop-join","children":[]},{"level":2,"title":"Block Nested - Loop Join","slug":"block-nested-loop-join","link":"#block-nested-loop-join","children":[]},{"level":2,"title":"code","slug":"code","link":"#code","children":[{"level":3,"title":"simple nested-loop join","slug":"simple-nested-loop-join-1","link":"#simple-nested-loop-join-1","children":[]},{"level":3,"title":"Block Nested-Loop Join","slug":"block-nested-loop-join-1","link":"#block-nested-loop-join-1","children":[]},{"level":3,"title":"两者区别：","slug":"两者区别","link":"#两者区别","children":[]},{"level":3,"title":"关于全表扫描","slug":"关于全表扫描","link":"#关于全表扫描","children":[]}]}],"git":{"updatedTime":1746338840000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"782aea8180789c4b3dd4cd07cb76b397e115be73","time":1746338840000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"}]},"filePathRelative":"guide/mysql/mysql45讲/34 -到底可不可以使用join.md"}');export{r as comp,u as data};
