import{_ as n,c as a,e,o as p}from"./app-DzmgiGLk.js";const t="/simple-doc/assets/MRR1-DHzjj0rl.png",l="/simple-doc/assets/bka-BFG__UUJ.png",o={};function i(c,s){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="join-语句优化" tabindex="-1"><a class="header-anchor" href="#join-语句优化"><span>Join 语句优化</span></a></h1><p>表结构</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> t1<span class="token punctuation">(</span>id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span> a <span class="token keyword">int</span><span class="token punctuation">,</span> b <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">index</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">drop</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">create</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">begin</span></span>
<span class="line">  <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">do</span></span>
<span class="line">    <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1001</span><span class="token operator">-</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token keyword">do</span></span>
<span class="line">    <span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">delimiter</span> <span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">call</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="multi-range-read-优化" tabindex="-1"><a class="header-anchor" href="#multi-range-read-优化"><span>Multi-Range Read 优化</span></a></h2><p>回忆一下回表。回表是指，InnoDB 在普通索引 a 上查到主键 id 的值后，再根据一个个主键 id 的值到主键 id 的值到主键索引上去查整行数据的过程。</p><p>主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。</p><p>因此，回表肯定是一行行搜索主键索引的。</p><p><img src="`+t+'" alt="MRR1"></p><p>如果随着 a 的值递增顺序查询的话，id 的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。</p><p>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</p><p>MRR 优化的设计思路：</p><ul><li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li><li>将 read_rnd_buffer 中的 id 进行递增排序；</li><li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li></ul><p>read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制。如果想要稳定地使用 MRR 优化的话，需要设置set optimizer_switch=“mrr_cost_based=off”，如果不设置，优化器会判断消耗，倾向于不使用MRR。</p><h2 id="batched-key-access" tabindex="-1"><a class="header-anchor" href="#batched-key-access"><span>Batched Key Access</span></a></h2><p>MySQL 在 5.6 版本后开始引入的 Batched Key Acess(BKA) 算法了。其实就是对 NLJ 算法的优化。</p><p>NLJ 算法执行的逻辑是：从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了。</p><p>BKA 算法就是缓存多行传给其他表，流程如下：</p><p><img src="'+l+`" alt="bka"></p><p>启动 BKA:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">set</span> optimizer_switch<span class="token operator">=</span><span class="token string">&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>BNL 算法的性能问题</p><p>上篇文章末尾说了，如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU 链表头部。 为了减少这种影响，可以考虑增大join_buffer_size 的值，减少对被驱动表的扫描次数。</p><p>优化的常见做法是，给被驱动表的 join 字段加上索引，把 BNL 算法转成 BKA 算法。 还可以考虑使用临时表。使用临时表的大致思路是：</p><ol><li>把表 t2 中满足条件的数据放在临时表 tmp_t 中；</li><li>为了让 join 使用 BKA 算法，给临时表 tmp_t 的字段 b 加上索引；</li><li>让表 t1 和 tmp_t 做 join 操作。</li></ol><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">create</span> <span class="token keyword">temporary</span> <span class="token keyword">table</span> temp_t<span class="token punctuation">(</span>id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span> a <span class="token keyword">int</span><span class="token punctuation">,</span> b <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">index</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> temp_t <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> b<span class="token operator">&gt;=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">&lt;=</span><span class="token number">2000</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">join</span> temp_t <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>b<span class="token operator">=</span>temp_t<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="扩展-hash-join" tabindex="-1"><a class="header-anchor" href="#扩展-hash-join"><span>扩展 -hash join</span></a></h2><p>mysql目前还没有hash索引，MariaDB支持。</p><p>所以可以自己实现在业务端。实现流程大致如下：</p><ol><li>select * from t1;取得表 t1 的全部 1000 行数据，在业务端存入一个 hash 结构；</li><li>select * from t2 where b&gt;=1 and b&lt;=2000; 获取表 t2 中满足条件的 2000 行数据。</li><li>把这 2000 行数据，一行一行地取到业务端，到 hash 结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li></ol><p>这个过程会比临时表方案的执行速度还要快一些。</p>`,30)]))}const d=n(o,[["render",i]]),k=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/35-Join%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96.html","title":"Join 语句优化","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Multi-Range Read 优化","slug":"multi-range-read-优化","link":"#multi-range-read-优化","children":[]},{"level":2,"title":"Batched Key Access","slug":"batched-key-access","link":"#batched-key-access","children":[]},{"level":2,"title":"扩展 -hash join","slug":"扩展-hash-join","link":"#扩展-hash-join","children":[]}],"git":{"updatedTime":1746338840000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"782aea8180789c4b3dd4cd07cb76b397e115be73","time":1746338840000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"}]},"filePathRelative":"guide/mysql/mysql45讲/35-Join语句优化.md"}');export{d as comp,k as data};
