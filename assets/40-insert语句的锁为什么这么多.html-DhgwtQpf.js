import{_ as n,c as a,e,o as p}from"./app-DlGl6QFf.js";const t="/simple-doc/assets/insert1-DAAC6a3h.png",l="/simple-doc/assets/insert2-Dqfo3edI.png",o="/simple-doc/assets/insert3-Be5pD2b_.png",i="/simple-doc/assets/insert4-DwqCIwbu.png",c="/simple-doc/assets/insert5-CAdriTzt.png",r="/simple-doc/assets/insert6-0671UV0u.png",k={};function u(d,s){return p(),a("div",null,s[0]||(s[0]=[e('<h1 id="_40-insert语句的锁为什么这么多" tabindex="-1"><a class="header-anchor" href="#_40-insert语句的锁为什么这么多"><span>40-insert语句的锁为什么这么多</span></a></h1><h2 id="_1-锁的种类" tabindex="-1"><a class="header-anchor" href="#_1-锁的种类"><span>1. 锁的种类</span></a></h2><ul><li>表锁：对表的结构加锁，防止其他进程对表结构的修改。</li><li>行锁：对表中某一行加锁，防止其他进程对该行的修改。</li><li>页锁：对表中一页的数据加锁，防止其他进程对该页的修改。</li><li>外键锁：对表中外键约束加锁，防止其他进程对该约束的修改。</li><li>死锁：两个或多个事务在同一资源上互相等待，导致无限等待。</li></ul><h3 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁"><span>表锁</span></a></h3><ul><li>X锁：对表结构加排它锁，防止其他进程对表结构的修改。</li><li>S锁：对表结构加共享锁，允许其他进程读取表结构，但不允许修改。</li><li>IS锁：对表结构加插入锁，允许其他进程读取表结构，但不允许插入或修改。</li><li>IX锁：对表结构加排它插入锁，防止其他进程对表结构的修改和插入。</li></ul><p>S锁和IX锁的冲突; X锁和任意锁的冲突; IX锁和其他锁兼容; IS锁和其他锁兼容。</p><h3 id="行锁" tabindex="-1"><a class="header-anchor" href="#行锁"><span>行锁</span></a></h3><ul><li>共享锁：允许其他进程读取某一行，但不允许修改。</li><li>排它锁：对某一行加排它锁，防止其他进程对该行的修改。</li><li>行锁的兼容性：S锁和X锁的冲突;S锁和IS锁的兼容;X锁和IX锁的冲突;IX锁和其他锁兼容。</li><li>Recond Lock: 允许对某一行进行读操作，但不允许对该行进行写操作。</li><li>Gap Lock: 允许对某一范围内的行进行读操作，但不允许对该范围内的行进行写操作。</li><li>Next-Key Lock: 允许对某一范围内的行进行读操作和写操作，但不允许对该范围外的行进行任何操作。</li></ul><h2 id="_2-insert语句的锁" tabindex="-1"><a class="header-anchor" href="#_2-insert语句的锁"><span>2. insert语句的锁</span></a></h2><ul><li>insert语句的锁类型：insert语句会对表加写锁，直到事务提交或回滚。</li><li>对于MyISAM表，insert语句会对整个表加写锁，直到事务提交或回滚。</li><li>对于InnoDB表，insert语句会对插入的行加写锁，直到事务提交或回滚。</li></ul><h3 id="insert-select-语句" tabindex="-1"><a class="header-anchor" href="#insert-select-语句"><span>insert … select 语句</span></a></h3><p>可重复读隔离级别下，binlog_format=statement。 表结构</p><p>准备</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span></span>\n<span class="line">  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span></span>\n<span class="line">  <span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>\n<span class="line">  <span class="token identifier"><span class="token punctuation">`</span>d<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>\n<span class="line">  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>\n<span class="line">  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span><span class="token punctuation">)</span></span>\n<span class="line"><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span></span>\n<span class="line"></span>\n<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"></span>\n<span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="'+t+`" alt="insert1"></p><p>session B执行时需要对表 t 的所有行和间隙加锁。 如果没有锁，就可能出现 session B 的 insert 语句先执行，但是后写入 binlog 的情况。所以会引起主备不一致。</p><h3 id="insert-循环写入" tabindex="-1"><a class="header-anchor" href="#insert-循环写入"><span>insert 循环写入</span></a></h3><p>执行 insert … select 的时候，对目标表也不是锁全表， 而是只锁住需要访问的资源。</p><p>现在有这么一个需求：要往表 t2 中插入一行数据，这一行的 c 值是表 t 中 c 值的最大值加 1。</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t2<span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">select</span> c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> d <span class="token keyword">from</span> t <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> c <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个语句的加锁范围，就是表 t 索引 c 上的 (3,4]和 (4,supremum] 这两个 next-key lock，以及主键索引上 id=4 这一行。</p><p>它的执行流程也比较简单，从表 t 中按照索引 c 倒序，扫描第一行，拿到结果写入到表 t2 中。</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t<span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">select</span> c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> d <span class="token keyword">from</span> t <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> c <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果执行这句sql，可以看到，这时候的 Rows_examined 的值是 5。并且使用了临时表。</p><p><img src="`+l+'" alt="insert2"><img src="'+o+'" alt="insert3"></p><p>Explain 结果 rows=1 是因为受到了 limit 1 的影响。可能不准确。 使用执行Innodb_rows_read 语句查看查看sql执行前后扫描行数。</p><p><img src="'+i+`" alt="insert4"></p><p>可以看到，这个语句执行前后，Innodb_rows_read 的值增加了 4。 因为默认临时表是使用 Memory 引擎的，所以这 4 行查的都是表 t，也就是说对表 t 做了全表扫描。 所以整个执行流程：</p><ol><li>创建临时表，表里有两个字段 c 和 d。</li><li>按照索引 c 扫描表 t，依次取 c=4、3、2、1，然后回表，读到 c 和 d 的值写入临时表。这时，Rows_examined=4。</li><li>由于语义里面有 limit 1，所以只取了临时表的第一行，再插入到表 t 中。这时，Rows_examined 的值加 1，变成了 5。</li></ol><p>这个语句会导致在表 t 上做全表扫描，并且会给索引 c 上的所有间隙都加上共享的 next-key lock。</p><p>这个语句的执行为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况， 如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。</p><p>由于实现上这个语句没有在子查询中就直接使用 limit 1，从而导致了这个语句的执行需要遍历整个表 t。</p><p>优化方案：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">create</span> <span class="token keyword">temporary</span> <span class="token keyword">table</span> temp_t<span class="token punctuation">(</span>c <span class="token keyword">int</span><span class="token punctuation">,</span>d <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">engine</span><span class="token operator">=</span>memory<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> temp_t  <span class="token punctuation">(</span><span class="token keyword">select</span> c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> d <span class="token keyword">from</span> t <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> c <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> temp_t<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">drop</span> <span class="token keyword">table</span> temp_t<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="insert-唯一键冲突" tabindex="-1"><a class="header-anchor" href="#insert-唯一键冲突"><span>insert 唯一键冲突</span></a></h3><p><img src="`+c+'" alt="insert5"></p><p>session A 执行的 insert 语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。 session A 持有索引 c 上的 (5,10] 共享 next-key lock（读锁）。</p><p>这个读锁作用上来看，这样做可以避免这一行被别的事务删掉。</p><p><img src="'+r+`" alt="insert6"></p><p>执行相同的 insert 语句，发现了唯一键冲突，加上读锁（Next-key lock）。session A 回滚，session B 和 session C 都试图继续执行插入操作，都要加上插入意向锁（LOCK_INSERT_INTENTION）。</p><p>insert into … on duplicate key update</p><p>语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">on</span> <span class="token keyword">duplicate</span> <span class="token keyword">key</span> <span class="token keyword">update</span> d<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行</p>`,44)]))}const y=n(k,[["render",u]]),b=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/40-insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A.html","title":"40-insert语句的锁为什么这么多","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"1. 锁的种类","slug":"_1-锁的种类","link":"#_1-锁的种类","children":[{"level":3,"title":"表锁","slug":"表锁","link":"#表锁","children":[]},{"level":3,"title":"行锁","slug":"行锁","link":"#行锁","children":[]}]},{"level":2,"title":"2. insert语句的锁","slug":"_2-insert语句的锁","link":"#_2-insert语句的锁","children":[{"level":3,"title":"insert … select 语句","slug":"insert-select-语句","link":"#insert-select-语句","children":[]},{"level":3,"title":"insert 循环写入","slug":"insert-循环写入","link":"#insert-循环写入","children":[]},{"level":3,"title":"insert 唯一键冲突","slug":"insert-唯一键冲突","link":"#insert-唯一键冲突","children":[]}]}],"git":{"updatedTime":1746293673000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"e5945ebdbc3e2b976f95add711e081bdd86f39b7","time":1746293673000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"}]},"filePathRelative":"guide/mysql/mysql45讲/40-insert语句的锁为什么这么多.md"}');export{y as comp,b as data};
