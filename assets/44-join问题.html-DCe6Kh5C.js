import{_ as s,c as a,e as p,o as e}from"./app-DzmgiGLk.js";const t="/simple-doc/assets/join-1-CCl04wq9.png",o="/simple-doc/assets/q1-explain-Z0SAWbNn.png",l="/simple-doc/assets/q2-explain-56He94lP.png",c="/simple-doc/assets/q2-turning-CPMk9-px.png",i="/simple-doc/assets/q3-join-B0x55vhW.png",u={};function r(k,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="_44-join问题" tabindex="-1"><a class="header-anchor" href="#_44-join问题"><span>44-join问题</span></a></h1><p>Join 写法</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> a<span class="token punctuation">(</span>f1 <span class="token keyword">int</span><span class="token punctuation">,</span> f2 <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">index</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> b<span class="token punctuation">(</span>f1 <span class="token keyword">int</span><span class="token punctuation">,</span> f2 <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> a <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> b <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>如果用 left join 的话，左边的表一定是驱动表吗？</li><li>如果两个表的 join 包含多个条件的等值匹配，是都要写到 on 里面呢，还是只把一个条件写到 on 里面，其他条件写到 where 部分？</li></ol><p>其实就是下面这两种写法的区别：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">left</span> <span class="token keyword">join</span> b <span class="token keyword">on</span> a<span class="token punctuation">.</span>f1<span class="token operator">=</span>b<span class="token punctuation">.</span>f1 <span class="token operator">and</span> a<span class="token punctuation">.</span>f2<span class="token operator">=</span>b<span class="token punctuation">.</span>f2<span class="token punctuation">;</span> <span class="token comment">/*Q1*/</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">left</span> <span class="token keyword">join</span> b <span class="token keyword">on</span> a<span class="token punctuation">.</span>f1<span class="token operator">=</span>b<span class="token punctuation">.</span>f1 <span class="token keyword">where</span> a<span class="token punctuation">.</span>f2<span class="token operator">=</span>b<span class="token punctuation">.</span>f2<span class="token punctuation">;</span> <span class="token comment">/*Q2*/</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Q1：左边的表是驱动表，因为左边的表的索引是 f1，所以 join 过程只会扫描左边的表，所以效率更高。</p><p>Q2：如果两个表的 join 包含多个条件的等值匹配，则都要写到 on 里面，因为 on 里面只能写一个条件，所以只能把一个条件写到 on 里面。</p><p><img src="`+t+'" alt="join"></p><p>Q1的explain：</p><p><img src="'+o+'" alt="q1-explain"></p><p>Q1使用BNL算法，第 35 篇文章《join 语句怎么优化？》中讲过。 Block Nested Loop 算法的特点是先对驱动表进行全表扫描，然后对每个匹配的结果，再对被驱动表进行一次全表扫描。</p><p>Q2的explain：</p><p><img src="'+l+'" alt="q2-explain"></p><p>Q1使用NLJ算法，执行流程是这样的：顺序扫描表 b，每一行用 b.f1 到表 a 中去查，匹配到记录后判断 a.f2=b.f2 是否满足，满足条件的话就作为结果集的一部分返回。</p><p>差别</p><p>在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。所以 Q2 没有1和2。</p><p>Q2这条语句虽然用的是 left join，但是语义跟 join 是一致的。优化器会把Q2优化成join。因为表 a 的 f1 上有索引，就把表 b 作为驱动表，这样就可以用上 NLJ 算法。使用show warning;可以看到优化后的语句。</p><p><img src="'+c+`" alt="q2-turning"></p><p>所以使用 left join 时，左边的表不一定是驱动表。 如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面。</p><p>再来看两条sql：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">join</span> b <span class="token keyword">on</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>f1<span class="token operator">=</span>b<span class="token punctuation">.</span>f1<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>f2<span class="token operator">=</span>b<span class="token punctuation">.</span>f2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*Q3*/</span></span>
<span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">join</span> b <span class="token keyword">on</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>f1<span class="token operator">=</span>b<span class="token punctuation">.</span>f1<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>f2<span class="token operator">=</span>b<span class="token punctuation">.</span>f2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*Q4*/</span></span>
<span class="line"><span class="token number">12</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+i+`" alt="q3-join"></p><p>在这种情况下，join 将判断条件是否全部放在 on 部分就没有区别了。</p><h2 id="simple-nested-loop-join-的性能问题" tabindex="-1"><a class="header-anchor" href="#simple-nested-loop-join-的性能问题"><span>Simple Nested Loop Join 的性能问题</span></a></h2><p>Simple Nested Loop Join 算法，其实也是把数据读到内存里，然后按照匹配条件进行判断，为什么性能差距会这么大呢？ 解释这个问题，需要用到 MySQL 中索引结构和 Buffer Pool 的相关知识点：</p><ol><li>在对被驱动表做全表扫描的时候，如果数据没有在 Buffer Pool 中，就需要等待这部分数据从磁盘读入；多次访问容易将这些数据页放到 Buffer Pool 的头部，影响 Buffer Pool 的命中率。</li><li>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而 join_buffer 中是数组，遍历的成本更低。</li></ol><h2 id="distinct-和-group-by-的性能" tabindex="-1"><a class="header-anchor" href="#distinct-和-group-by-的性能"><span>distinct 和 group by 的性能</span></a></h2><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">select</span> a <span class="token keyword">from</span> t <span class="token keyword">group</span> <span class="token keyword">by</span> a <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token boolean">null</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">select</span> <span class="token keyword">distinct</span> a <span class="token keyword">from</span> t<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>group by 没有聚合函数，这两句sql的效率相同。</p><ol><li>创建一个临时表，临时表有一个字段 a，并且在这个字段 a 上创建一个唯一索引；</li><li>遍历表 t，依次取数据插入临时表中：如果发现唯一键冲突，就跳过；否则插入成功；</li><li>遍历完成后，将临时表作为结果集返回给客户端</li></ol><h2 id="备库自增主键问题" tabindex="-1"><a class="header-anchor" href="#备库自增主键问题"><span>备库自增主键问题</span></a></h2><p>第 39 篇文章《自增主键为什么不是连续的？》评论区，@帽子掉了 同学问到：在 binlog_format=statement 时，语句 A 先获取 id=1，然后语句 B 获取 id=2；接着语句 B 提交，写 binlog，然后语句 A 再写 binlog。这时候，如果 binlog 重放，是不是会发生语句 B 的 id 为 1，而语句 A 的 id 为 2 的不一致情况呢？ 不会，虽然 statement 格式下“自增 id 的生成顺序，和 binlog 的写入顺序可能是不同的”。</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> t<span class="token punctuation">(</span>id <span class="token keyword">int</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>主库上语句 A 的 id 是 1，语句 B 的 id 是 2，但是写入 binlog 的顺序先 B 后 A，那么binlog 就变成：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">set</span> insert_id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">statement B<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">set</span> insert_id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">statement A<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,36)]))}const m=s(u,[["render",r]]),b=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/44-join%E9%97%AE%E9%A2%98.html","title":"44-join问题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Simple Nested Loop Join 的性能问题","slug":"simple-nested-loop-join-的性能问题","link":"#simple-nested-loop-join-的性能问题","children":[]},{"level":2,"title":"distinct 和 group by 的性能","slug":"distinct-和-group-by-的性能","link":"#distinct-和-group-by-的性能","children":[]},{"level":2,"title":"备库自增主键问题","slug":"备库自增主键问题","link":"#备库自增主键问题","children":[]}],"git":{"updatedTime":1746293673000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"e5945ebdbc3e2b976f95add711e081bdd86f39b7","time":1746293673000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"}]},"filePathRelative":"guide/mysql/mysql45讲/44-join问题.md"}');export{m as comp,b as data};
