import{_ as s,c as a,e,o as i}from"./app-DlGl6QFf.js";const d={};function l(t,n){return i(),a("div",null,n[0]||(n[0]=[e(`<h1 id="自增id用完怎么办" tabindex="-1"><a class="header-anchor" href="#自增id用完怎么办"><span>自增id用完怎么办</span></a></h1><p>表定义自增值 id 表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> t<span class="token punctuation">(</span>id <span class="token keyword">int</span> <span class="token keyword">unsigned</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">)</span> <span class="token keyword">auto_increment</span><span class="token operator">=</span><span class="token number">4294967295</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 成功插入一行 4294967295</span></span>
<span class="line"><span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> t<span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">/* CREATE TABLE \`t\` (</span>
<span class="line">  \`id\` int(10) unsigned NOT NULL AUTO_INCREMENT,</span>
<span class="line">  PRIMARY KEY (\`id\`)</span>
<span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4294967295;</span>
<span class="line">*/</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//Duplicate entry &#39;4294967295&#39; for key &#39;PRIMARY&#39;</span></span>
<span class="line"><span class="token number">123456789101112</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主键冲突，如果 4 个字节无符号整型 (unsigned int) 不够用的情况下，可以使用 8 个字节的 bigint unsigned。</p><h2 id="innodb-系统自增-row-id" tabindex="-1"><a class="header-anchor" href="#innodb-系统自增-row-id"><span>InnoDB 系统自增 row_id</span></a></h2><p>如果你创建的InnoDB表没有指定主键， 那么InnoDB会给你创建一个不可见的， 长度为6个字节的row_id。 InnoDB维护了一个全局的dict_sys.row_id值， 所有无主键的InnoDB表， 每插入一行数据， 都将当前的dict_sys.row_id值作为要插入数据的row_id， 然后把dict_sys.row_id的值加1。</p><h2 id="xid" tabindex="-1"><a class="header-anchor" href="#xid"><span>Xid</span></a></h2><p>redo log 和 binlog 相配合的时候，它们有一个共同的字段叫作 Xid。它在 MySQL 中是用来对应事务的。 MySQL 内部维护了一个全局变量 global_query_id，每次执行语句的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。 而 global_query_id 是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是唯一的。 不过 global_query_id 达到上限后，会继续从 0 开始计数，由于 global_query_id 为8个字节，所以一般不会出现到达上限的情况。</p><h2 id="innodb-trx-id" tabindex="-1"><a class="header-anchor" href="#innodb-trx-id"><span>Innodb trx_id</span></a></h2><p>Xid 是由 server 层维护的。InnoDB 内部使用 Xid ，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。 InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。 InnoDB 数据可见性的核心思想是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。 对于正在执行的事务，你可以从 information_schema.innodb_trx 表中看到事务的 trx_id。 但是对于只读事务，InnoDB 并不会分配 trx_id。</p><p>max_trx_id 会持久化存储，重启也不会重置为 0，那么从理论上讲，只要一个 MySQL 服务跑得足够久，就可能到达上限，然后从 0 开始的情况。然后就会导致脏读。但只存在理论上，如果一个 MySQL 实例的 TPS 是每秒 50 万，持续这个压力的话，在 17.8 年后，就会出现这个情况。</p><h2 id="thread-id" tabindex="-1"><a class="header-anchor" href="#thread-id"><span>thread_id</span></a></h2><p>show processlist 里面的第一列，就是 thread_id。 系统保存了一个全局变量 thread_id_counter，每新建一个连接，就将 thread_id_counter 赋值给这个新连接的线程变量。 thread_id_counter 定义的大小是 4 个字节，到达上限则从0开始。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>每种自增id有各自的应用场景， 在达到上限后的表现也不同：</p><ol><li>表的自增id达到上限后， 再申请时它的值就不会改变， 进而导致继续插入数据时报主键冲突的错误。</li><li>row_id达到上限后， 则会归0再重新递增， 如果出现相同的row_id， 后写的数据会覆盖之前的数据。</li><li>Xid只需要不在同一个binlog文件中出现重复值即可。 虽然理论上会出现重复值， 但是概率极小， 可以忽略不计。</li><li>InnoDB的max_trx_id 递增值每次MySQL重启都会被保存起来， 所以我们文章中提到的脏读的例子就是一个必现的bug， 好在留给我们的时间还很充裕。</li><li>thread_id是我们使用中最常见的， 而且也是处理得最好的一个自增id逻辑了。</li></ol>`,16)]))}const r=s(d,[["render",l]]),p=JSON.parse('{"path":"/guide/mysql/mysql45%E8%AE%B2/45-id-over.html","title":"自增id用完怎么办","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"InnoDB 系统自增 row_id","slug":"innodb-系统自增-row-id","link":"#innodb-系统自增-row-id","children":[]},{"level":2,"title":"Xid","slug":"xid","link":"#xid","children":[]},{"level":2,"title":"Innodb trx_id","slug":"innodb-trx-id","link":"#innodb-trx-id","children":[]},{"level":2,"title":"thread_id","slug":"thread-id","link":"#thread-id","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1746293673000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"e5945ebdbc3e2b976f95add711e081bdd86f39b7","time":1746293673000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"}]},"filePathRelative":"guide/mysql/mysql45讲/45-id-over.md"}');export{r as comp,p as data};
