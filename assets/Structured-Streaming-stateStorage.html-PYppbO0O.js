import{_ as o}from"./20250420010-DhL5IorG.js";import{_ as p,c as l,e as n,a as i,d as s,b as c,w as r,r as u,o as d}from"./app-DzmgiGLk.js";const e="/simple-doc/assets/20250420011-CQmeCfqs.png",m="/simple-doc/assets/20250420012-BUgHqtid.png",k={};function v(S,a){const t=u("RouteLink");return d(),l("div",null,[a[3]||(a[3]=n(`<h1 id="structured-streaming-之状态存储解析" tabindex="-1"><a class="header-anchor" href="#structured-streaming-之状态存储解析"><span>Structured Streaming 之状态存储解析</span></a></h1><p><strong><em>[ Spark] Structured Streaming 源码解析系列</em></strong></p><div class="language-markdown line-numbers-mode" data-highlighter="prismjs" data-ext="md"><pre><code><span class="line">本文内容适用范围：</span>
<span class="line"><span class="token list punctuation">*</span> 2018.11.02 update, Spark 2.4 全系列 √ (已发布：2.4.0)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,3)),i("p",null,[a[1]||(a[1]=s("阅读本文前，请一定先阅读  ")),c(t,{to:"/guide/etl/spark/Structured-Streaming-Implementation-and-Overview.html"},{default:r(()=>a[0]||(a[0]=[s("Structured Streaming 实现思路与实现概述")])),_:1}),a[2]||(a[2]=s("  一文，其中概述了 Structured Streaming 的实现思路（包括 StreamExecution, StateStore 等在 Structured Streaming 里的作用），有了全局概念后再看本文的细节解释。"))]),a[4]||(a[4]=n('<h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言"><span>引言</span></a></h2><p>我们知道，持续查询的驱动引擎 StreamExecution 会持续不断地驱动每个批次的执行。</p><p>对于不需要跨批次的持续查询，如 <code>map()</code>, <code>filter()</code> 等，每个批次之间的执行相互独立，不需要状态支持。而比如类似 <code>count()</code> 的聚合式持续查询，则需要跨批次的状态支持，这样本批次的执行只需依赖上一个批次的结果，而不需要依赖之前所有批次的结果。这也即增量式持续查询，能够将每个批次的执行时间稳定下来，避免越后面的批次执行时间越长的情形。</p><p>这个增量式持续查询的思路和实现，我们在 [Structured Streaming 实现思路与实现概述](1.1 Structured Streaming 实现思路与实现概述.md) 解析过：</p><p align="center"><img src="'+o+'"></p><p>而在这里面的 StateStore，即是 Structured Streaming 用于保存跨批次状态结果的模块组件。本文解析 StateStore 模块。</p><h2 id="statestore-模块的总体思路" tabindex="-1"><a class="header-anchor" href="#statestore-模块的总体思路"><span>StateStore 模块的总体思路</span></a></h2><p align="center"><img src="'+e+'"></p><p>StateStore 模块的总体思路：</p><ul><li>分布式实现 <ul><li>跑在现有 Spark 的 driver-executors 架构上</li><li>driver 端是轻量级的 coordinator，只做协调工作</li><li>executor 端负责状态的实际分片的读写</li></ul></li><li>状态分片 <ul><li>因为一个应用里可能会包含多个需要状态的 operator，而且 operator 本身也是分 partition 执行的，所以状态存储的分片以 <code>operatorId</code>+<code>partitionId</code> 为切分依据</li><li>以分片为基本单位进行状态的读入和写出</li><li>每个分片里是一个 key-value 的 store，key 和 value 的类型都是 <code>UnsafeRow</code>（可以理解为 SparkSQL 里的 Object 通用类型），可以按 key 查询、或更新</li></ul></li><li>状态分版本 <ul><li>因为 StreamExection 会持续不断地执行批次，因而同一个 operator 同一个 partition 的状态也是随着时间不断更新、产生新版本的数据</li><li>状态的版本是与 StreamExecution 的进展一致，比如 StreamExection 的批次 id = 7 完成时，那么所有 version = 7 的状态即已经持久化</li></ul></li><li>批量读入和写出分片 <ul><li>对于每个分片，读入时 <ul><li>根据 operator + partition + version， 从 HDFS 读入数据，并缓存在内存里</li></ul></li><li>对于每个分片，写出时 <ul><li>累计当前版本（即 StreamExecution 的当前批次）的多行的状态修改，一次性写出到 HDFS 一个修改的流水 log，流水 log 写完即标志本批次的状态修改完成</li><li>同时应用修改到内存中的状态缓存</li></ul></li></ul></li></ul><p>关于 StateStore 的 operator, partiton, version 有一个图片可帮助理解：</p><p align="center"><img src="'+m+'"></p><h2 id="statestore-a-迁移、-b-更新和查询、-c-维护、-d-故障恢复" tabindex="-1"><a class="header-anchor" href="#statestore-a-迁移、-b-更新和查询、-c-维护、-d-故障恢复"><span>StateStore：(a)迁移、(b)更新和查询、(c)维护、(d)故障恢复</span></a></h2><p align="center"><img src="'+e+`"></p><h3 id="a-statestore-在不同的节点之间如何迁移" tabindex="-1"><a class="header-anchor" href="#a-statestore-在不同的节点之间如何迁移"><span>(a) StateStore 在不同的节点之间如何迁移</span></a></h3><p>在 StreamExecution 执行过程中，随时在 operator 实际执行的 executor 节点上唤起一个状态存储分片、并读入前一个版本的数据即可（如果 executor 上已经存在一个分片，那么就直接重用，不用唤起分片、也不用读入数据了）。</p><p>我们上节讲过，持久化的状态是在 HDFS 上的。那么如上图所示：</p><ul><li><code>executor a</code>, 唤起了 <code>operator = 1, partition = 1</code> 的状态存储分片，从 HDFS 里位于本机的数据副本 load 进来 <code>version = 5</code> 的数据；</li><li>一个 executor 节点可以执行多个 operator，那么也就可以在一个 executor 上唤起多个状态存储分片（分别对应不同的 operator + partition），如图示 <code>executor b</code>；</li><li>在一些情况下，需要从其他节点的 HDFS 数据副本上 load 状态数据，如图中 <code>executor c</code> 需要从 <code>executor b</code> 的硬盘上 load 数据；</li><li>另外还有的情况是，同一份数据被同时 load 到不同的 executor 上，如 <code>executor d</code> 和 <code>executor a</code> 即是读入了同一份数据 —— 推测执行时就容易产生这种情况 —— 这时也不会产生问题，因为 load 进来的是同一份数据，然后在两个节点上各自修改，最终只会有一个节点能够成功提交对状态的修改。</li></ul><h3 id="b-statestore-的更新和查询" tabindex="-1"><a class="header-anchor" href="#b-statestore-的更新和查询"><span>(b) StateStore 的更新和查询</span></a></h3><p>我们前面也讲过，在一个状态存储分片里，是 key-value 的 store。这个 key-value 的 store 支持如下操作：</p><div class="language-scala line-numbers-mode" data-highlighter="prismjs" data-ext="scala"><pre><code><span class="line">  <span class="token comment">/* == CRUD 增删改查 =============================== */</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 查询一条 key-value</span></span>
<span class="line">  <span class="token keyword">def</span> get<span class="token punctuation">(</span>key<span class="token operator">:</span> UnsafeRow<span class="token punctuation">)</span><span class="token operator">:</span> Option<span class="token punctuation">[</span>UnsafeRow<span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 新增、或修改一条 key-value</span></span>
<span class="line">  <span class="token keyword">def</span> put<span class="token punctuation">(</span>key<span class="token operator">:</span> UnsafeRow<span class="token punctuation">,</span> value<span class="token operator">:</span> UnsafeRow<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 删除一条符合条件的 key-value</span></span>
<span class="line">  <span class="token keyword">def</span> remove<span class="token punctuation">(</span>condition<span class="token operator">:</span> UnsafeRow <span class="token keyword">=&gt;</span> <span class="token builtin">Boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span></span>
<span class="line">  <span class="token comment">// 根据 key 删除 key-value</span></span>
<span class="line">  <span class="token keyword">def</span> remove<span class="token punctuation">(</span>key<span class="token operator">:</span> UnsafeRow<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">/* == 批量操作相关 =============================== */</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 提交当前执行批次的所有修改，将刷出到 HDFS，成功后版本将自增</span></span>
<span class="line">  <span class="token keyword">def</span> commit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Long</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 放弃当前执行批次的所有修改</span></span>
<span class="line">  <span class="token keyword">def</span> abort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 当前状态分片、当前版本的所有 key-value 状态</span></span>
<span class="line">  <span class="token keyword">def</span> iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token punctuation">[</span><span class="token punctuation">(</span>UnsafeRow<span class="token punctuation">,</span> UnsafeRow<span class="token punctuation">)</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 当前状态分片、当前版本比上一个版本的所有增量更新</span></span>
<span class="line">  <span class="token keyword">def</span> updates<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token punctuation">[</span>StoreUpdate<span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 StateStore 的代码可以这样写（现在都是 Structured Streaming 内部实现在使用 StateStore，上层用户无需面对这些细节）：</p><div class="language-scala line-numbers-mode" data-highlighter="prismjs" data-ext="scala"><pre><code><span class="line">  <span class="token comment">// 在最开始，获取正确的状态分片(按需重用已有分片或读入新的分片)</span></span>
<span class="line">  <span class="token keyword">val</span> store <span class="token operator">=</span> StateStore<span class="token punctuation">.</span>get<span class="token punctuation">(</span>StateStoreId<span class="token punctuation">(</span>checkpointLocation<span class="token punctuation">,</span> operatorId<span class="token punctuation">,</span> partitionId<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> version<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 开始进行一些更改</span></span>
<span class="line">  store<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span>
<span class="line">  store<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 更改完成，批量提交缓存在内存里的更改到 HDFS</span></span>
<span class="line">  store<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 查看当前状态分片的所有 key-value / 刚刚更新了的 key-value</span></span>
<span class="line">  store<span class="token punctuation">.</span>iterator<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  store<span class="token punctuation">.</span>updates<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="c-statestore-的维护" tabindex="-1"><a class="header-anchor" href="#c-statestore-的维护"><span>(c) StateStore 的维护</span></a></h3><p>我们看到，前面 StateStore 在写出状态的更新时，是写出的修改流水 log。</p><p>StateStore 本身也带了 maintainess 即维护模块，会周期性的在后台将过去的状态和最近若干版本的流水 log 进行合并，并把合并后的结果重新写回到 HDFS：<code>old_snapshot + delta_a + delta_b + … =&gt; lastest_snapshot</code>。</p><p>这个过程跟 HBase 的 major/minor compact 差不多，但还没有区别到 major/minor 的粒度。</p><h3 id="d-statestore-的故障恢复" tabindex="-1"><a class="header-anchor" href="#d-statestore-的故障恢复"><span>(d) StateStore 的故障恢复</span></a></h3><p>StateStore 的所有状态以 HDFS 为准。如果某个状态分片在更新过程中失败了，那么还没有写出的更新会不可见。</p><p>恢复时也是从 HDFS 读入最近可见的状态，并配合 StreamExecution 的执行批次重做。从另一个角度说，就是大家 —— 输入数据、及状态存储 —— 先统一往后会退到本执行批次刚开始时的状态，然后重新计算。当然这里重新计算的粒度是 Spark 的单个 task，即一个 partition 的输入数据 + 一个 partition 的状态存储。</p><p>从 HDFS 读入最近可见的状态时，如果有最新的 snapshot，也就用最新的 snapshot，如果没有，就读入稍旧一点的 snapshot 和新的 deltas，先做一下最新状态的合并。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>在 Structured Streaming 里，StateStore 模块提供了 <strong><em>分片的</em></strong>、<strong><em>分版本的</em></strong>、<strong><em>可迁移的</em></strong>、<strong><em>高可用</em></strong> key-value store。</p><p>基于这个 StateStore 模块，StreamExecution 实现了 <strong><em>增量的</em></strong> 持续查询、和很好的故障恢复以维护 <strong><em>end-to-end exactly-once guarantees</em></strong>。</p><h2 id="扩展阅读" tabindex="-1"><a class="header-anchor" href="#扩展阅读"><span>扩展阅读</span></a></h2><ol><li><a href="https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/state/StateStore.scala" target="_blank" rel="noopener noreferrer">Github: org/apache/spark/sql/execution/streaming/state/StateStore.scala</a></li><li><a href="https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/state/HDFSBackedStateStoreProvider.scala" target="_blank" rel="noopener noreferrer">Github: org/apache/spark/sql/execution/streaming/state/HDFSBackedStateStoreProvider.scala</a></li></ol><br><br>`,38))])}const g=p(k,[["render",v]]),f=JSON.parse('{"path":"/guide/etl/spark/Structured-Streaming-stateStorage.html","title":"Structured Streaming 之状态存储解析","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"引言","slug":"引言","link":"#引言","children":[]},{"level":2,"title":"StateStore 模块的总体思路","slug":"statestore-模块的总体思路","link":"#statestore-模块的总体思路","children":[]},{"level":2,"title":"StateStore：(a)迁移、(b)更新和查询、(c)维护、(d)故障恢复","slug":"statestore-a-迁移、-b-更新和查询、-c-维护、-d-故障恢复","link":"#statestore-a-迁移、-b-更新和查询、-c-维护、-d-故障恢复","children":[{"level":3,"title":"(a) StateStore 在不同的节点之间如何迁移","slug":"a-statestore-在不同的节点之间如何迁移","link":"#a-statestore-在不同的节点之间如何迁移","children":[]},{"level":3,"title":"(b) StateStore 的更新和查询","slug":"b-statestore-的更新和查询","link":"#b-statestore-的更新和查询","children":[]},{"level":3,"title":"(c) StateStore 的维护","slug":"c-statestore-的维护","link":"#c-statestore-的维护","children":[]},{"level":3,"title":"(d) StateStore 的故障恢复","slug":"d-statestore-的故障恢复","link":"#d-statestore-的故障恢复","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"扩展阅读","slug":"扩展阅读","link":"#扩展阅读","children":[]}],"git":{"updatedTime":1753257234000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":3,"url":"https://github.com/alice"}],"changelog":[{"hash":"48409442c8c1f37ba42fad99036599dd52c923e4","time":1753257234000,"email":"921757697@qq.com","author":"alice","message":"deploy uniapp 组件"},{"hash":"245816fee7920b84913505a4353b6b4f934da7c0","time":1753237474000,"email":"921757697@qq.com","author":"alice","message":"uniapp 组件"},{"hash":"7706e85b299e47a4a064f79e4ce4f11f0e5f015c","time":1745114781000,"email":"921757697@qq.com","author":"alice","message":"doc 整理"}]},"filePathRelative":"guide/etl/spark/Structured-Streaming-stateStorage.md"}');export{g as comp,f as data};
