import{_ as e,c as o,e as i,o as r}from"./app-DzmgiGLk.js";const a="/simple-doc/assets/mysql-buffer-pool-CBlJZC3E.png",s="/simple-doc/assets/changebuffer-DQ5Q6lcB.png",n="/simple-doc/assets/free-link-tB5v0Uuk.png",f="/simple-doc/assets/bufferpool2-DYNacetz.png",t="/simple-doc/assets/mysql-arch2-eZyPu9sp.png",c={};function u(d,l){return r(),o("div",null,l[0]||(l[0]=[i('<h1 id="mysql-buffer-pool" tabindex="-1"><a class="header-anchor" href="#mysql-buffer-pool"><span>MySQL Buffer Pool</span></a></h1><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><p>Buffer pool is a memory area where MySQL stores data that is being read or written to disk. It is responsible for reducing disk I/O operations and improving query performance.</p><p>为了提高读写效率，MySQL使用了缓冲池.缓冲池是一个内存区域，其中存储了需要从磁盘读取或写入的数据.缓冲池的作用是减少磁盘I/O操作，提高查询性能.</p><p><img src="'+a+'" alt="buffer pool"></p><ol><li>客户端--》执行器</li><li>执行器到缓存中查询数据，没有就到磁盘查询，并将缓存数据加载到buffer pool中.</li><li>将旧数据记录到Undo log中，便于回滚数据,mvcc.</li><li>客服端进行更新SQL，将buffer pool中的缓存页数据更新，此时缓存页被更新的数据就是脏页(dirty page,跟数据库中的数据不一致).</li><li>将脏页数据写入磁盘，并清空缓存页.</li><li>缓存页被清空，下次再访问该页时，会重新从磁盘读取.</li><li>更新数据前先写redo log, 记录更新操作，写入redolog buffer.便于crash recovery.数据恢复时，从redolog文件中恢复数据. <ul><li>参数 innodb_flush_method=O_DIRECT, 即将数据写入磁盘时，使用O_DIRECT方式，避免系统调用.</li><li>参数 innodb_log_file_size=5M, 即redolog文件大小为5M.</li><li>参数 innodb_log_buffer_size=8M, 即redolog buffer大小为8M.</li><li>参数 innodb_flush_log_at_trx_commit=1, 实时写，实时刷</li><li>参数 innodb_flush_log_at_trx_commit=2, 实时写，延迟刷</li><li>参数 innodb_flush_log_at_trx_commit=0, 延迟写，延迟刷,后台延迟1s写.</li></ul></li><li>遇到commit, 将redolog buffer中的数据写入Page Cache, 并清空redolog buffer.</li><li>后台线程将Page Cache 中的数据fsync 到redolog文件中.</li><li>准备提交事务, sync_binlog=0, 事务提交时，不写入binlog.写入page cache, 后台线程将page cache中的数据fsync到binlog文件中. sync_binlog=1, 事务提交时，写入binlog.</li></ol><ul><li>redolog: 解决系统异常数据恢复问题.</li><li>binlog: 记录数据库的变更信息, 用于主从复制.</li><li>undolog: 记录数据修改前的状态, 用于数据回滚.</li><li>page cache: 缓存磁盘数据, 减少磁盘I/O.</li><li>buffer pool: 缓存数据, 减少内存使用.</li><li>flush: 将脏页数据写入磁盘.</li><li>fsync: 将数据写入磁盘.</li><li>mvcc: 多版本并发控制, 解决脏读问题.</li><li>dirty page: 脏页, 跟数据库中的数据不一致.</li><li>flush log: 将redolog buffer中的数据写入Page Cache, 并清空redolog buffer.</li></ul><h2 id="bufferpool和changebuffer是如何加快数据读写速度的" tabindex="-1"><a class="header-anchor" href="#bufferpool和changebuffer是如何加快数据读写速度的"><span>BufferPool和ChangeBuffer是如何加快数据读写速度的</span></a></h2><p><img src="'+s+'" alt="changebuffer"></p><p>buffer pool</p><ul><li>instance groups 实例数组</li><li>chunk groups 缓存快数组, 128M</li><li>blocks groups 控制块数组</li></ul><p>page,16KB</p><p>instance1:</p><ul><li>block1,block2,...,碎片,page-1,page-2,...,碎片</li></ul><p><img src="'+n+'" alt="free-linked list"></p><p>free linked table: free 链表，存储缓存的数据 flush linked table: flush 链表，存储需要刷新的缓存页</p><p><img src="'+f+'" alt="bufferpool2"> 线性预读, innodb_read_ahead_threshold=16M, 预读16M数据到buffer pool中. innodb_read_ahead_threshold=12, 预读12个页的数据到buffer pool中. 随机预读，innodb_random_read_aheah=on, 随机预读数据到buffer pool中.</p><h2 id="mysql-数据结构" tabindex="-1"><a class="header-anchor" href="#mysql-数据结构"><span>MySQL 数据结构</span></a></h2><p><img src="'+t+'" alt="arch2"></p><ul><li>内存结构 In-Memory Data Structures: 内存数据结构, 如 Hash, B-Tree, RB-Tree, AVL-Tree, Splay-Tree, Skip-List, 等.</li><li>磁盘结构 On-Disk Data Structures: 磁盘数据结构, 如 B+Tree, LSM-Tree, 等.</li></ul><h3 id="内存结构" tabindex="-1"><a class="header-anchor" href="#内存结构"><span>内存结构</span></a></h3><ul><li>Buffer Pool: 缓存池，作用就是用来缓存表数据和索引数据，减少磁盘IO操作，提高查询性能.</li><li>Change Buffer: 变更缓存，写缓存区，是针对二级索引页（辅助索引）的更新优化措施.</li><li>Log Buffer: 日志缓存，用来缓存写入磁盘上log文件(redolog和binlog)的数据，日志缓存区的内容会定期的刷新到磁盘log文件中.主要作用是，用来优化每次更新操作之后都要写入redolog文件，降低磁盘IO操作.</li><li>Adaptive Hash Index: 自适应哈希索引，是一种索引结构，它根据访问的频率来动态调整索引的高度，以提高查询效率.大数据量的访问场景下，自适应哈希索引可以有效降低磁盘IO操作. InnoDB 不支持手动创建哈希索引的，但是InnoDB会进行自调优，如果判断自适应哈希索引能够提升查询效率，InnoDB会自动创建哈希索引.</li></ul>',22)]))}const h=e(c,[["render",u]]),g=JSON.parse('{"path":"/guide/mysql/mysql-buffer-pool.html","title":"MySQL Buffer Pool","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[]},{"level":2,"title":"BufferPool和ChangeBuffer是如何加快数据读写速度的","slug":"bufferpool和changebuffer是如何加快数据读写速度的","link":"#bufferpool和changebuffer是如何加快数据读写速度的","children":[]},{"level":2,"title":"MySQL 数据结构","slug":"mysql-数据结构","link":"#mysql-数据结构","children":[{"level":3,"title":"内存结构","slug":"内存结构","link":"#内存结构","children":[]}]}],"git":{"updatedTime":1746034246000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":2,"url":"https://github.com/alice"}],"changelog":[{"hash":"daf3790ef1795d02fbff734cf83b3c856cbb378c","time":1746034246000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"},{"hash":"016b58ed194f53d02856d8698f36fa1b7d96101d","time":1745299077000,"email":"921757697@qq.com","author":"alice","message":"doc 整理"}]},"filePathRelative":"guide/mysql/mysql-buffer-pool.md"}');export{h as comp,g as data};
