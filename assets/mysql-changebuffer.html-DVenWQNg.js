import{_ as a,c as f,e as n,o as r}from"./app-DlGl6QFf.js";const l={};function h(c,e){return r(),f("div",null,e[0]||(e[0]=[n('<h1 id="mysql-change-buffer" tabindex="-1"><a class="header-anchor" href="#mysql-change-buffer"><span>MySQL Change Buffer</span></a></h1><h2 id="changebuffer-为什么不针对聚簇索引" tabindex="-1"><a class="header-anchor" href="#changebuffer-为什么不针对聚簇索引"><span>changebuffer 为什么不针对聚簇索引</span></a></h2><p>Change Buffer 不针对聚簇索引是因为聚簇索引的更新具有特殊性（直接影响数据页、更新频率低、即时性要求高）， 且优化聚簇索引的写操作收益有限。</p><p>Change Buffer 的设计初衷是通过缓存辅助索引的写操作来减少随机 I/O，这与聚簇索引的更新模式不匹配。</p><p>因此，InnoDB 选择仅对辅助索引应用 Change Buffer 优化。</p><ul><li>Change Buffer 优化的对象：仅对辅助索引的写操作。</li><li>辅助索引写操作可批量合并： 比如短时间内对辅助索引进行多次插入操作，这些操作暂存于change buffer中，之后一次性写入磁盘。就是将多次写入转换成一次顺序写入。</li><li>聚簇索引写操作难以批量优化： 聚簇索引的写操作通常是随机且分散的，尤其是当数据更新涉及不同的数据页时，难以像辅助索引那样通过缓存操作来合并随机 I/O。例如，插入一条新记录时，若聚簇索引为自增主键，虽然插入顺序相对固定，但更新数据页的操作依然复杂，无法通过 Change Buffer 有效减少 I/O 次数。</li></ul>',6)]))}const s=a(l,[["render",h]]),i=JSON.parse('{"path":"/guide/mysql/mysql-changebuffer.html","title":"MySQL Change Buffer","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"changebuffer 为什么不针对聚簇索引","slug":"changebuffer-为什么不针对聚簇索引","link":"#changebuffer-为什么不针对聚簇索引","children":[]}],"git":{"updatedTime":1746778681000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"9a9a724e2266d508b01cf98d17493fda41251e3d","time":1746778681000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql 手绘图"}]},"filePathRelative":"guide/mysql/mysql-changebuffer.md"}');export{s as comp,i as data};
