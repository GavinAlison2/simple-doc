import{_ as l,c as s,e as a,o as n}from"./app-DlGl6QFf.js";const i="/simple-doc/assets/mysql-sql-execute-process-B1UB1bqP.png",o={};function c(d,e){return n(),s("div",null,e[0]||(e[0]=[a('<h1 id="mysql-面试题" tabindex="-1"><a class="header-anchor" href="#mysql-面试题"><span>MySQL 面试题</span></a></h1><h2 id="_1-mysql是怎么执行一条sql语句" tabindex="-1"><a class="header-anchor" href="#_1-mysql是怎么执行一条sql语句"><span>1. MySQL是怎么执行一条SQL语句</span></a></h2><ol><li><p>连接管理与权限验证</p><ul><li>客户端与 MySQL 服务器建立连接，服务器会验证客户端的身份和权限，只有通过验证的用户才能执行后续操作。</li></ul></li><li><p>解析</p><ul><li>词法分析：MySQL 将输入的 SQL 语句按照词法规则进行拆分，识别出关键字、标识符、常量等。例如，对于语句<code>SELECT * FROM users WHERE age &gt; 18;</code>，会将其拆分为<code>SELECT</code>（关键字）、<code>*</code>（通配符）、<code>FROM</code>（关键字）、<code>users</code>（表名，标识符）等。</li><li>语法分析：根据 MySQL 的语法规则，对词法分析后的结果进行语法检查和结构分析，构建出对应的解析树。如果 SQL 语句语法错误，在此阶段就会被发现并返回错误信息。</li></ul></li><li><p>查询优化</p><ul><li>逻辑优化：对解析树进行优化，例如简化查询条件、消除冗余的子查询或视图等。如查询<code>SELECT * FROM (SELECT * FROM users) AS t;</code>，会被优化为<code>SELECT * FROM users;</code>。</li><li>物理优化：根据表的索引、数据分布等信息，选择最优的查询执行计划，包括决定使用何种索引、连接方式以及表的扫描顺序等。例如，若users表的age字段上有索引，对于<code>SELECT * FROM users WHERE age &gt; 18;</code>语句，优化器可能会选择使用该索引来快速定位满足条件的记录。</li></ul></li><li><p>查询执行</p><ul><li>按照优化后的执行计划，调用存储引擎的接口来获取数据。如果需要进行表连接、排序、分组等操作，在这个阶段会按照相应的算法进行处理。例如，使用嵌套循环连接算法来连接多个表，使用快速排序算法对结果集进行排序等。</li></ul></li><li><p>结果集返回</p><ul><li>将查询结果返回给客户端。如果查询语句是INSERT、UPDATE、DELETE等修改数据的操作，则返回受影响的行数等信息。</li></ul></li></ol><ul><li>undo log, mvcc</li><li>redolog，wal</li><li>binlog，备份，主从</li></ul><p><img src="'+i+`" alt="mysql-execute-process"></p><h2 id="_2-redo-log" tabindex="-1"><a class="header-anchor" href="#_2-redo-log"><span>2. redo log</span></a></h2><p>redo log 是 MySQL 用于保证数据持久性的一种机制。在 MySQL 中，每当有一条记录被更新，MySQL 都会先写入 redo log，然后再更新内存，以此来确保数据持久性。当事务提交时，redo log 被写入磁盘，并清空，以保证数据完整性。</p><ul><li>事务持久性</li><li>数据一致性，完整性</li><li>崩溃恢复, 恢复数据库最后一次正常运行的状态，通过执行redo log记录的操作. 重播机制.</li><li>性能优化， redo log 减少随机写，改成顺序写，提高性能，减少磁盘 IO。异步刷新redo buffer.</li></ul><p>innodb_flush_log_at_trx_commit=1，表示每次事务提交时，都将 redo log 写入磁盘。innodb_flush_log_at_trx_commit=0，表示系统崩溃时，只有 redo log 未写入磁盘，数据可能丢失。</p><p>innodb 内存 -&gt; redo log -&gt; 磁盘</p><blockquote><p><a href="https://www.bilibili.com/video/BV1Zz42197cF/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=5a41e8ae8c0a4c2c6809a5ccf977c1a9" target="_blank" rel="noopener noreferrer">redo log video</a></p></blockquote><h2 id="_3-为什么不能使用自增id或者uuid做mysql的主键-雪花算法生成的主键存在哪些问题" tabindex="-1"><a class="header-anchor" href="#_3-为什么不能使用自增id或者uuid做mysql的主键-雪花算法生成的主键存在哪些问题"><span>3. 为什么不能使用自增ID或者UUID做MySQL的主键，雪花算法生成的主键存在哪些问题</span></a></h2><ol><li>在MySQL的分布式架构中，为什么不能使用自增主键</li><li>UUID可以用来做主键吗？ 存在哪些问题?</li><li>雪花算法生成的主键存在哪些问题？snowFlake 算法的原理，介绍一下它有哪些优势和不足？</li></ol><p>case1: 自增ID</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span> t1 <span class="token punctuation">(</span></span>
<span class="line">    id <span class="token keyword">int</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span></span>
<span class="line">    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span> <span class="token keyword">default</span> <span class="token keyword">charset</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-1-uuid可以用来做主键吗-存在哪些问题" tabindex="-1"><a class="header-anchor" href="#_3-1-uuid可以用来做主键吗-存在哪些问题"><span>3.1 UUID可以用来做主键吗？ 存在哪些问题?</span></a></h3><p>UUID 是随机生成的，每次当插入记录时，需要查找定位位置，会导致数据写入效率低下，并且可能伴随着数据的移动. 不同于自增的数据的批量插入，直接定位数据，顺序插入，比UUID插入的效率高。</p><p>UUID 是由 32个十六进制数字和4个连字符组成的，不好阅读.</p><h3 id="_3-2-雪花算法原理" tabindex="-1"><a class="header-anchor" href="#_3-2-雪花算法原理"><span>3.2 雪花算法原理？</span></a></h3><p>分布式 ID 生成算法</p><p>工作原理:</p><ul><li>当前时间戳</li><li>机器标识</li><li>序列号</li></ul><p>当需要生成一个 ID 时，算法首先获取当前的时间戳，然后根据工作机器 ID 和序列号生成一个唯一的 ID。如果在同一毫秒内有多个 ID 需要生成，序列号会自动递增，以确保每个 ID 都是唯一的。如果序列号达到了最大值，算法会等待下一个毫秒的到来，然后重新从 0 开始计数。</p><p>缺点：</p><ul><li>依赖时钟，如果时钟回拨，会存在id重复的情况。</li><li>存储的时间最长 69年，存在用尽的可能。</li></ul>`,25)]))}const p=l(o,[["render",c]]),r=JSON.parse(`{"path":"/guide/mysql/mysql-%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"MySQL 面试题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"1. MySQL是怎么执行一条SQL语句","slug":"_1-mysql是怎么执行一条sql语句","link":"#_1-mysql是怎么执行一条sql语句","children":[]},{"level":2,"title":"2. redo log","slug":"_2-redo-log","link":"#_2-redo-log","children":[]},{"level":2,"title":"3. 为什么不能使用自增ID或者UUID做MySQL的主键，雪花算法生成的主键存在哪些问题","slug":"_3-为什么不能使用自增id或者uuid做mysql的主键-雪花算法生成的主键存在哪些问题","link":"#_3-为什么不能使用自增id或者uuid做mysql的主键-雪花算法生成的主键存在哪些问题","children":[{"level":3,"title":"3.1 UUID可以用来做主键吗？ 存在哪些问题?","slug":"_3-1-uuid可以用来做主键吗-存在哪些问题","link":"#_3-1-uuid可以用来做主键吗-存在哪些问题","children":[]},{"level":3,"title":"3.2 雪花算法原理？","slug":"_3-2-雪花算法原理","link":"#_3-2-雪花算法原理","children":[]}]}],"git":{"updatedTime":1746293673000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":5,"url":"https://github.com/alice"}],"changelog":[{"hash":"e5945ebdbc3e2b976f95add711e081bdd86f39b7","time":1746293673000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"},{"hash":"daf3790ef1795d02fbff734cf83b3c856cbb378c","time":1746034246000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql"},{"hash":"9207f2aad99db4bacb122519d8ae1cf0c3c973c5","time":1745740041000,"email":"921757697@qq.com","author":"alice","message":"'deploy'"},{"hash":"f7bb0736efe804ddc4b5f84eb5afc36065fa16c8","time":1745674048000,"email":"921757697@qq.com","author":"alice","message":"deploy it"},{"hash":"016b58ed194f53d02856d8698f36fa1b7d96101d","time":1745299077000,"email":"921757697@qq.com","author":"alice","message":"doc 整理"}]},"filePathRelative":"guide/mysql/mysql-面试题.md"}`);export{p as comp,r as data};
