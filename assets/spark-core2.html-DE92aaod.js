import{_ as s,c as a,e as p,o as e}from"./app-DKrcH86L.js";const t={};function l(c,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="spark-core" tabindex="-1"><a class="header-anchor" href="#spark-core"><span>Spark Core</span></a></h1><p>三大数据结构</p><ul><li>RDD: 弹性分布式数据集</li><li>累加器: 分布式共享只写变量</li><li>广播变量: 分布式共享只读变量</li></ul><h2 id="rdd-持久化" tabindex="-1"><a class="header-anchor" href="#rdd-持久化"><span>RDD 持久化</span></a></h2><ol><li>RDD Cache 缓存</li></ol><p>​ RDD 通过 Cache 或者 Persist 方法将前面的计算结果缓存，默认情况下会把数据以缓存在 JVM 的堆内存中。但是并不是这两个方法被调用时立即缓存，而是触发后面的 action 算子时，该 RDD 将会被缓存在计算节点的内存中，并供后面重用。</p><ol start="2"><li>RDD CheckPoint 检查点</li></ol><p>​ 所谓的检查点其实就是通过将 RDD 中间结果写入磁盘,由于血缘依赖过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果检查点之后有节点出现问题，可以从检查点开始重做血缘，减少了开销。对 RDD 进行 checkpoint 操作并不会马上被执行，必须执行 Action 操作才能触发。</p><div class="language-scala line-numbers-mode" data-highlighter="prismjs" data-ext="scala"><pre><code><span class="line"><span class="token comment">// 设置检查点路径</span></span>
<span class="line">sc<span class="token punctuation">.</span>setCheckpointDir<span class="token punctuation">(</span><span class="token string">&quot;./checkpoint1&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// 创建一个 RDD，读取指定位置文件:hello atguigu atguigu</span></span>
<span class="line"><span class="token keyword">val</span> lineRdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">&quot;input/1.txt&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//业务逻辑</span></span>
<span class="line"><span class="token keyword">val</span> wordRdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> lineRdd<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>line <span class="token keyword">=&gt;</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">val</span> wordToOneRdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Long</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> wordRdd<span class="token punctuation">.</span>map <span class="token punctuation">{</span></span>
<span class="line">    word <span class="token keyword">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span>word<span class="token punctuation">,</span> System<span class="token punctuation">.</span>currentTimeMillis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span> </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">//增加缓存,避免再重新跑一个 job 做 checkpoint</span></span>
<span class="line">wordToOneRdd<span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//数据检查点：针对 wordToOneRdd 做检查点计算</span></span>
<span class="line">wordToOneRdd<span class="token punctuation">.</span>checkpoint<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//触发执行逻辑</span></span>
<span class="line">wordToOneRdd<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>缓存和检查点区别</li></ol><p>1）Cache 缓存只是将数据保存起来，不切断血缘依赖。Checkpoint 检查点切断血缘依赖。</p><p>2）Cache 缓存的数据通常存储在磁盘、内存等地方，可靠性低。Checkpoint 的数据通常存储在 HDFS 等容错、高可用的文件系统，可靠性高。</p><p>3）建议对 checkpoint()的 RDD 使用 Cache 缓存，这样 checkpoint 的 job 只需从 Cache 缓存中读取数据即可，否则需要再从头计算一次 RDD。</p><h2 id="rdd-分区器" tabindex="-1"><a class="header-anchor" href="#rdd-分区器"><span>RDD 分区器</span></a></h2><p>Spark 目前支持 Hash 分区和 Range 分区，和用户自定义分区。Hash 分区为当前的默认分区。分区器直接决定了 RDD 中分区的个数、RDD 中每条数据经过 Shuffle 后进入哪个分区，进而决定了 Reduce 的个数。</p><ul><li>只有 Key-Value 类型的 RDD 才有分区器，非 Key-Value 类型的 RDD 分区的值是 None</li><li>每个 RDD 的分区 ID 范围：0 ~ (numPartitions - 1)，决定这个值是属于那个分区的。</li></ul><ol><li><p>Hash 分区：对于给定的 key，计算其 hashCode,并除以分区个数取余</p></li><li><p>Range 分区：将 key 映射到一个范围区间，然后将区间划分为分区数，每个分区包含一个区间。</p></li></ol><h2 id="rdd-文件读取与保存" tabindex="-1"><a class="header-anchor" href="#rdd-文件读取与保存"><span>RDD 文件读取与保存</span></a></h2><p>Spark 的数据读取及数据保存可以从两个维度来作区分：文件格式以及文件系统。</p><p>文件格式分为：text 文件、csv 文件、sequence 文件以及 Object 文件；</p><p>文件系统分为：本地文件系统、HDFS、HBASE 以及数据库。</p><ul><li>text 文件</li><li>sequence 文件, ​ SequenceFile 文件是 Hadoop 用来存储二进制形式的 key-value 对而设计的一种平面文件(FlatFile)</li><li>object 对象文件, 对象文件是将对象序列化后保存的文件，采用 Java 的序列化机制。可以通过 <code>objectFile[T: ClassTag](path)</code>函数接收一个路径，读取对象文件，返回对应的 RDD，也可以通过调用saveAsObjectFile()实现对对象文件的输出。因为是序列化所以要指定类型</li></ul><div class="language-scala line-numbers-mode" data-highlighter="prismjs" data-ext="scala"><pre><code><span class="line"><span class="token comment">// 读取输入文件</span></span>
<span class="line"><span class="token keyword">val</span> inputRDD<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">&quot;input/1.txt&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// 保存数据</span></span>
<span class="line">inputRDD<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">&quot;output&quot;</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 保存数据为 SequenceFile</span></span>
<span class="line">dataRDD<span class="token punctuation">.</span>saveAsSequenceFile<span class="token punctuation">(</span><span class="token string">&quot;output&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// 读取 SequenceFile 文件</span></span>
<span class="line">sc<span class="token punctuation">.</span>sequenceFile<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">,</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">&quot;output&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 保存数据</span></span>
<span class="line">dataRDD<span class="token punctuation">.</span>saveAsObjectFile<span class="token punctuation">(</span><span class="token string">&quot;output&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// 读取数据</span></span>
<span class="line">sc<span class="token punctuation">.</span>objectFile<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">&quot;output&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="累加器" tabindex="-1"><a class="header-anchor" href="#累加器"><span>累加器</span></a></h2><h3 id="_1-实现原理" tabindex="-1"><a class="header-anchor" href="#_1-实现原理"><span>1. 实现原理</span></a></h3><p>​ 累加器用来把 Executor 端变量信息聚合到 Driver 端。在 Driver 程序中定义的变量，在Executor 端的每个 Task 都会得到这个变量的一份新的副本，每个 task 更新这些副本的值后，传回 Driver 端进行 merge。</p><h3 id="_2-基础编程" tabindex="-1"><a class="header-anchor" href="#_2-基础编程"><span>2. 基础编程</span></a></h3><div class="language-scala line-numbers-mode" data-highlighter="prismjs" data-ext="scala"><pre><code><span class="line"><span class="token keyword">val</span> rdd <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//声明累加器</span></span>
<span class="line"><span class="token keyword">var</span> sum <span class="token operator">=</span> sc<span class="token punctuation">.</span>longAccumulator<span class="token punctuation">(</span><span class="token string">&quot;sum&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">rdd<span class="token punctuation">.</span>foreach<span class="token punctuation">(</span> num <span class="token keyword">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 使用累加器</span></span>
<span class="line">    sum<span class="token punctuation">.</span>add<span class="token punctuation">(</span>num<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// 获取累加器的值</span></span>
<span class="line">println<span class="token punctuation">(</span><span class="token string">&quot;sum = &quot;</span> <span class="token operator">+</span> sum<span class="token punctuation">.</span>value<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-自定义累加器 line-numbers-mode" data-highlighter="prismjs" data-ext="自定义累加器"><pre><code><span class="line">// 自定义累加器</span>
<span class="line">// 1. 继承 AccumulatorV2，并设定泛型</span>
<span class="line">// 2. 重写累加器的抽象方法</span>
<span class="line">class WordCountAccumulator extends AccumulatorV2[String, mutable.Map[String, Long]]{</span>
<span class="line">    var map : mutable.Map[String, Long] = mutable.Map()</span>
<span class="line">    // 累加器是否为初始状态</span>
<span class="line">    override def isZero: Boolean = {</span>
<span class="line">        map.isEmpty</span>
<span class="line">    }</span>
<span class="line">    // 复制累加器</span>
<span class="line">    override def copy(): AccumulatorV2[String, mutable.Map[String, Long]] = {</span>
<span class="line">        new WordCountAccumulator</span>
<span class="line">    }</span>
<span class="line">    // 重置累加器</span>
<span class="line">    override def reset(): Unit = {</span>
<span class="line">        map.clear()</span>
<span class="line">    }</span>
<span class="line">    // 向累加器中增加数据 (In)</span>
<span class="line">    override def add(word: String): Unit = {</span>
<span class="line">        // 查询 map 中是否存在相同的单词</span>
<span class="line">        // 如果有相同的单词，那么单词的数量加 1</span>
<span class="line">        // 如果没有相同的单词，那么在 map 中增加这个单词</span>
<span class="line">        map(word) = map.getOrElse(word, 0L) + 1L</span>
<span class="line">    } </span>
<span class="line">    // 合并累加器</span>
<span class="line">    override def merge(other: AccumulatorV2[String, mutable.Map[String, Long]]): Unit = {</span>
<span class="line">        val map1 = map</span>
<span class="line">        val map2 = other.value</span>
<span class="line">        // 两个 Map 的合并</span>
<span class="line">        map = map1.foldLeft(map2)(</span>
<span class="line">            ( innerMap, kv ) =&gt; {</span>
<span class="line">                innerMap(kv._1) = innerMap.getOrElse(kv._1, 0L) + kv._2</span>
<span class="line">                innerMap</span>
<span class="line">            }) </span>
<span class="line">    }</span>
<span class="line">    // 返回累加器的结果 （Out）</span>
<span class="line">    override def value: mutable.Map[String, Long] = map</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="广播变量" tabindex="-1"><a class="header-anchor" href="#广播变量"><span>广播变量</span></a></h2><h3 id="_1-实现原理-1" tabindex="-1"><a class="header-anchor" href="#_1-实现原理-1"><span>1. 实现原理</span></a></h3><p>​ 广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的只读值，以供一个或多个 Spark 操作使用。比如，如果你的应用需要向所有节点发送一个较大的只读查询表，广播变量用起来都很顺手。在多个并行操作中使用同一个变量，但是 Spark 会为每个任务分别发送。</p><h3 id="_2-基础编程-1" tabindex="-1"><a class="header-anchor" href="#_2-基础编程-1"><span>2. 基础编程</span></a></h3><div class="language-scala line-numbers-mode" data-highlighter="prismjs" data-ext="scala"><pre><code><span class="line"><span class="token keyword">val</span> rdd1 <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// 声明广播变量</span></span>
<span class="line"><span class="token keyword">val</span> broadcast<span class="token operator">:</span> Broadcast<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>broadcast<span class="token punctuation">(</span>list<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">val</span> resultRDD<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>map <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line">        <span class="token comment">// 使用广播变量</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">&lt;-</span> broadcast<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                num2 <span class="token operator">=</span> v</span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>num<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span> </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">resultRDD<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,34)]))}const o=s(t,[["render",l]]),u=JSON.parse('{"path":"/guide/etl/spark/spark-core2.html","title":"Spark Core","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"RDD 持久化","slug":"rdd-持久化","link":"#rdd-持久化","children":[]},{"level":2,"title":"RDD 分区器","slug":"rdd-分区器","link":"#rdd-分区器","children":[]},{"level":2,"title":"RDD 文件读取与保存","slug":"rdd-文件读取与保存","link":"#rdd-文件读取与保存","children":[]},{"level":2,"title":"累加器","slug":"累加器","link":"#累加器","children":[{"level":3,"title":"1. 实现原理","slug":"_1-实现原理","link":"#_1-实现原理","children":[]},{"level":3,"title":"2. 基础编程","slug":"_2-基础编程","link":"#_2-基础编程","children":[]}]},{"level":2,"title":"广播变量","slug":"广播变量","link":"#广播变量","children":[{"level":3,"title":"1. 实现原理","slug":"_1-实现原理-1","link":"#_1-实现原理-1","children":[]},{"level":3,"title":"2. 基础编程","slug":"_2-基础编程-1","link":"#_2-基础编程-1","children":[]}]}],"git":{"updatedTime":1744907061000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"6865a6735449381c1fba9a14aa9ad0c9bd2e80fc","time":1744907061000,"email":"921757697@qq.com","author":"alice","message":"deploy"}]},"filePathRelative":"guide/etl/spark/spark-core2.md"}');export{o as comp,u as data};
