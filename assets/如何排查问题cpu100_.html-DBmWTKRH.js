import{_ as n,c as s,e,o as p}from"./app-DN6Q4pKI.js";const l={};function t(i,a){return p(),s("div",null,a[0]||(a[0]=[e(`<h1 id="如何排查问题cpu100" tabindex="-1"><a class="header-anchor" href="#如何排查问题cpu100"><span>如何排查问题cpu100%</span></a></h1><h2 id="一、引子" tabindex="-1"><a class="header-anchor" href="#一、引子"><span>一、引子</span></a></h2><p>对于互联网公司，线上CPU飙升的问题很常见（例如某个活动开始，流量突然飙升时），按照本文的步骤排查，基本1分钟即可搞定！特此整理排查方法一篇，供大家参考讨论提高。</p><h2 id="二、问题复现" tabindex="-1"><a class="header-anchor" href="#二、问题复现"><span>二、问题复现</span></a></h2><p>线上系统突然运行缓慢，CPU飙升，甚至到100%，以及Full GC次数过多，接着就是各种报警：例如接口超时报警等。此时急需快速线上排查问题。</p><h2 id="三、问题排查" tabindex="-1"><a class="header-anchor" href="#三、问题排查"><span>三、问题排查</span></a></h2><p>不管什么问题，既然是CPU飙升，肯定是查一下耗CPU的线程，然后看看GC。</p><h3 id="_3-1-核心排查步骤" tabindex="-1"><a class="header-anchor" href="#_3-1-核心排查步骤"><span>3.1 核心排查步骤</span></a></h3><ol><li><p>执行top命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</p></li><li><p>执行top -Hp 进程号命令：查看java进程下的所有线程占CPU的情况。</p></li><li><p>执行printf &quot;%x\\n 10命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如,printf &quot;%x\\n 10-》打印：a，那么在jstack中线程号就是0xa.</p></li><li><p>执行 jstack 进程号 | grep 线程ID 查找某进程下-》线程ID（jstack堆栈信息中的nid）=0xa的线程状态。如果&quot;VM Thread&quot; os_prio=0 tid=0x00007f871806e000 nid=0xa runnable，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了</p></li><li><p>执行jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计），查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大-》确认Full GC! 也可以使用jmap -heap 进程ID查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。</p></li><li><p>执行jmap -dump:format=b,file=filename 进程ID，导出某进程下内存heap输出到文件中。可以通过eclipse的mat工具查看内存中有哪些对象比较多。</p></li></ol><h3 id="_3-2-原因分析" tabindex="-1"><a class="header-anchor" href="#_3-2-原因分析"><span>3.2 原因分析</span></a></h3><p>1.内存消耗过大，导致Full GC次数过多 执行步骤1-5：</p><ul><li><p>多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程-》上一节步骤2</p></li><li><p>通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。--》上一节步骤5</p></li></ul><p>确定是Full GC,接下来找到具体原因：</p><p>生成大量的对象，导致内存溢出-》执行步骤6，查看具体内存对象占用情况。</p><p>内存占用不高，但是Full GC次数还是比较多，此时可能是代码中手动调用 System.gc()导致GC次数过多，这可以通过添加 -XX:+DisableExplicitGC来禁用JVM对显示GC的响应。</p><p>2.代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢；</p><p>执行步骤1-4：在步骤4jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。</p><p>3.由于锁使用不当，导致死锁。</p><p>执行步骤1-4：如果有死锁，会直接提示。关键字：deadlock.步骤四，会打印出业务死锁的位置。</p><p>造成死锁的原因：最典型的就是2个线程互相等待对方持有的锁。</p><p>4.随机出现大量线程访问接口缓慢。</p><p>代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的；平时消耗的CPU不多，而且占用的内存也不高。</p><p>思路：</p><p>首先找到该接口，通过压测工具不断加大访问力度，大量线程将阻塞于该阻塞点。</p><p>执行步骤1-4：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token string">&quot;http-nio-8080-exec-4&quot;</span> <span class="token comment">#31 daemon prio=5 os_prio=31 tid=0x00007fd08d0fa000 nid=0x6403 waiting on condition [0x00007000033db000]</span></span>
<span class="line">   java.lang.Thread.State: TIMED_WAITING <span class="token punctuation">(</span>sleeping<span class="token punctuation">)</span>-》期限等待</span>
<span class="line">    at java.lang.Thread.sleep<span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span></span>
<span class="line">    at java.lang.Thread.sleep<span class="token punctuation">(</span>Thread.java:340<span class="token punctuation">)</span></span>
<span class="line">    at java.util.concurrent.TimeUnit.sleep<span class="token punctuation">(</span>TimeUnit.java:386<span class="token punctuation">)</span></span>
<span class="line">    at com.*.user.controller.UserController.detail<span class="token punctuation">(</span>UserController.java:18<span class="token punctuation">)</span>-》业务代码阻塞点</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上，找到业务代码阻塞点，这里业务代码使用了TimeUnit.sleep()方法，使线程进入了TIMED_WAITING(期限等待)状态。</p><p>5.某个线程由于某种原因而进入WAITING状态，此时该功能整体不可用，但是无法复现；</p><p>执行步骤1-4：jstack多查询几次，每次间隔30秒，对比一直停留在parking 导致的WAITING状态的线程。</p><p>例如CountDownLatch倒计时器，使得相关线程等待-&gt;AQS-&gt;LockSupport.park()。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token string">&quot;Thread-0&quot;</span> <span class="token comment">#11 prio=5 os_prio=31 tid=0x00007f9de08c7000 nid=0x5603 waiting on condition [0x0000700001f89000]   </span></span>
<span class="line">java.lang.Thread.State: WAITING <span class="token punctuation">(</span>parking<span class="token punctuation">)</span> -<span class="token operator">&gt;</span>无期限等待</span>
<span class="line">at sun.misc.Unsafe.park<span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    </span>
<span class="line">at java.util.concurrent.locks.LockSupport.park<span class="token punctuation">(</span>LockSupport.java:304<span class="token punctuation">)</span>    </span>
<span class="line">at com.*.SyncTask.lambda<span class="token variable">$main</span><span class="token variable">$0</span><span class="token punctuation">(</span>SyncTask.java:8<span class="token punctuation">)</span>-》业务代码阻塞点</span>
<span class="line">at com.*.SyncTask<span class="token variable">$$</span>Lambda<span class="token variable">$1</span>/1791741888.run<span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>    </span>
<span class="line">at java.lang.Thread.run<span class="token punctuation">(</span>Thread.java:748<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,31)]))}const o=n(l,[["render",t]]),r=JSON.parse('{"path":"/guide/Java%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98cpu100_.html","title":"如何排查问题cpu100%","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"一、引子","slug":"一、引子","link":"#一、引子","children":[]},{"level":2,"title":"二、问题复现","slug":"二、问题复现","link":"#二、问题复现","children":[]},{"level":2,"title":"三、问题排查","slug":"三、问题排查","link":"#三、问题排查","children":[{"level":3,"title":"3.1 核心排查步骤","slug":"_3-1-核心排查步骤","link":"#_3-1-核心排查步骤","children":[]},{"level":3,"title":"3.2 原因分析","slug":"_3-2-原因分析","link":"#_3-2-原因分析","children":[]}]}],"git":{"updatedTime":1746693850000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"585489a27a9c17b77597dde58884e41006c86787","time":1746693850000,"email":"921757697@qq.com","author":"alice","message":"deploy mysql 手绘图"}]},"filePathRelative":"guide/Java场景题/如何排查问题cpu100%.md"}');export{o as comp,r as data};
