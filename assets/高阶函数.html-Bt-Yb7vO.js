import{_ as i,c as e,e as a,o as t}from"./app-CLlotT7k.js";const s={};function n(o,l){return t(),e("div",null,l[0]||(l[0]=[a('<h1 id="高阶函数" tabindex="-1"><a class="header-anchor" href="#高阶函数"><span>高阶函数</span></a></h1><ul><li>函数类型</li><li>call</li><li>apply</li><li>bind</li><li>闭包</li><li>柯里化</li><li>偏函数</li><li>函数柯里化</li><li>IFE 立即执行函数</li><li>箭头函数</li><li>rest 参数</li><li>扩展运算符</li><li>装饰器</li></ul><h2 id="函数类型" tabindex="-1"><a class="header-anchor" href="#函数类型"><span>函数类型</span></a></h2><ul><li>Function <ul><li>length 参数个数</li><li>prototype 原型对象</li><li>new 构造函数 new.target, new add(1,2) 直接调用, 返回 <code>Function add</code></li><li>apply, work.apply(person, dosomethins) , 改变this指向, 第二个参数是数组, 函数work内部的this指向person, 立即执行</li><li>call, work.call(person, ...rest), 改变this指向，第二个参数是逗号分隔的多个值, 立即执行</li><li>bind, work.bind(person), 改变this指向，返回一个新的函数，不执行, 简单理解就是借用方法,或者复制方法,改变函数名,改变函数内部的this指向, 定义而已</li><li>闭包 closure, 函数内部定义的变量，外部可以访问到，外部可以访问到函数内部的变量，形成一个封闭的空间.</li></ul></li></ul>',4)]))}const c=i(s,[["render",n]]),d=JSON.parse('{"path":"/guide/es6/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0.html","title":"高阶函数","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"函数类型","slug":"函数类型","link":"#函数类型","children":[]}],"git":{"updatedTime":1744907061000,"contributors":[{"name":"alice","username":"alice","email":"921757697@qq.com","commits":1,"url":"https://github.com/alice"}],"changelog":[{"hash":"6865a6735449381c1fba9a14aa9ad0c9bd2e80fc","time":1744907061000,"email":"921757697@qq.com","author":"alice","message":"deploy"}]},"filePathRelative":"guide/es6/高阶函数.md"}');export{c as comp,d as data};
