# JVM 垃圾回收机制

## 一些名词

- minor GC：指的是新生代的垃圾回收，发生在新生代的 Eden 区满时，或者 Survivor 区满时。
- major GC：指的是老年代的垃圾回收，发生在老年代空间不足时。
- Full GC：指的是整个堆空间的垃圾回收，发生在老年代空间不足时，或者 System.gc() 被调用时。
- yong gc: 指的是新生代的垃圾回收。
- old gc: 指的是老年代的垃圾回收。

-类型,发生区域,触发条件,回收速度,STW,时间
-Minor GC（Young GC）,新生代,Eden 区空间满,快,短
-Full GC,整个堆内存（新生代、老年代、永久代 / 元空间）,老年代空间不足、永久代 / 元空间不足、显式调用 System.gc() 等,慢,长
-Old GC,老年代,老年代空间达到阈值等,较慢,较长

## 垃圾回收算法

- 标记-清除算法：首先标记出所有需要回收的对象，然后统一回收掉标记的对象，标记-清除算法会产生内存碎片。
- 复制算法：将内存分为大小相同的两块，每次使用其中一块，当这一块内存用完时，就将还存活的对象复制到另一块上面，然后清理掉使用过的内存，复制算法不会产生内存碎片。

## 垃圾回收机制

- 分代回收
- 标记清除
- 复制算法
- 标记整理(压缩)
- 分代收集算法
  - 新生代中对象的存活时间较短，采用复制算法进行垃圾回收
  - 老年代中对象的存活时间较长，采用标记清除或标记整理算法进行垃圾回收

### 原理

- 标记可达对象：垃圾回收器会从一组被称为 “根” 的对象开始，例如全局变量、当前执行方法的局部变量等。通过跟踪这些根对象所引用的其他对象，以及这些被引用对象再引用的其他对象，以此类推，标记出所有可达的对象，即程序在运行过程中还在使用的对象。

### 分代收集

将堆内存分为新生代和老年代，新生代中存放的是短命的对象，老年代中存放的是长命的对象。

### 标记复制
  
将内存空间一分为二，每次只使用其中一块，当这一块内存用完时，就将还存活的对象复制到另一块上面，然后清理掉使用过的内存。

为什么标记复制一般在年轻代？

因为年轻代存活对象一般比较少，创建的对象存活时间短

- 标记：从根集合开始，对所有可达对象进行标记，不可达对象不标记。
- 复制：将标记过的对象复制到另一块内存上，清理掉原内存。

### 标记清除

将内存空间分为两块，每次只使用其中一块，当这一块内存用完时，就将还存活的对象直接清理掉，不进行复制。

- 标记：从根集合开始，对所有可达对象进行标记，不可达对象不标记。
- 清除：清理掉所有标记过的对象，释放内存。
- 复制：将存活对象复制到另一块内存上，清理掉原内存。
- 缺点：产生内存碎片，不能直接分配大对象。
- 适用场景：老年代空间不足时，触发Full GC。
- 触发条件：老年代空间不足、永久代 / 元空间不足、显式调用 System.gc() 等。
- 回收速度：慢。
- 时间：长。

### 标记整理

标记复制算法在对象存活率较高时，效率较低，所以需要对标记后的对象进行整理。

- 标记：从根集合开始，对所有可达对象进行标记，不可达对象不标记。
- 整理：将存活对象往一端移动，直到所有存活对象都在一块内存上。
- 复制：将存活对象复制到另一块内存上，清理掉原内存。

### 哪些对象可以当作GC ROOT

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象.
   每个方法在执行时都会创建一个栈帧，栈帧中的局部变量表存储了方法中的局部变量。这些局部变量所引用的对象可以作为 GC Roots。例如，在一个 Java 方法中定义的对象引用变量，只要该方法还在执行，这个引用所指向的对象就不会被回收，因为它是从虚拟机栈中的局部变量表可达的。
2. 方法区中类静态属性引用的对象.
   类的静态属性是属于类级别的变量，它们在方法区中存储。静态属性所引用的对象在整个应用程序的生命周期内通常都是可达的，除非该类被卸载。例如，一个全局的静态缓存对象，被多个地方引用，只要应用程序在运行，这个缓存对象就会通过类静态属性的引用作为 GC Roots 存在，不会被垃圾回收。
3. 方法区中常量引用的对象.
   方法区中的常量也是全局可见的，常量所引用的对象同样可以作为 GC Roots。例如，字符串常量池中的字符串对象，当一个字符串常量被定义后，其他地方如果使用到相同的字符串，实际上是引用了字符串常量池中的同一个对象，这个对象会因为常量的引用而作为 GC Roots，不会被轻易回收。
4. 本地方法栈中 JNI（Native 方法）引用的对象.
   当 Java 程序调用 Native 方法时，Native 方法可能会在本地方法栈中持有对一些 Java 对象的引用。这些通过 JNI 引用的对象也会被当作 GC Roots，以确保它们在 Native 方法执行期间不会被回收。因为如果这些对象被回收了，Native 方法再访问它们时就会出现错误。

### 新生代/老年代回收器

- 新生代垃圾回收器
  - Serial 收集器
  - Parallel 收集器
  - CMS 收集器
  - G1 收集器
  - ZGC 收集器
- 老年代垃圾回收器
  - Serial Old 收集器
  - Parallel Old 收集器
  - CMS Old 收集器
  - G1 Old 收集器

```md
工作原理：采用复制算法，是单线程的垃圾回收器。在进行垃圾回收时，它会暂停所有的用户线程，直到垃圾回收完成。

优点：实现简单，没有线程交互的开销，在单线程环境下效率较高。

缺点：会导致用户线程的停顿，在回收大量垃圾时，STW停顿时间可能会比较长，影响应用的响应时间。

适用场景：适用于小型应用，或者对响应时间要求不高的应用。

-XX:+UseSerialGC：设置串行垃圾回收器。
-XX:+UseSerialOldGC：设置串行老年代垃圾回收器。
```

- ParNew 收集器

```md
工作原理：是 Serial 收集器的多线程版本，同样采用复制算法。它可以利用多个 CPU 核心同时进行垃圾回收，从而缩短垃圾回收的时间。

优点：多线程回收，效率比 Serial 收集器高，能够在较短的时间内完成垃圾回收，减少用户线程的停顿时间。

缺点：在多核环境下，虽然提高了回收速度，但由于多个线程同时运行，会增加一定的线程调度和上下文切换的开销。

适用场景：适用于多核处理器的环境，并且与 CMS 收集器配合使用时效果较好，因为 CMS 收集器在新生代回收时通常会使用 ParNew 收集器。

-XX:+UseParNewGC：设置 ParNew 收集器。

```

- Parallel Scavenge 收集器

```md
工作原理：也是基于复制算法的多线程收集器。它的目标是达到一个可控制的吞吐量，通过控制垃圾回收时间和用户程序执行时间的比例，来满足不同应用对吞吐量的要求。

优点：可以通过参数设置来精确控制吞吐量，能够根据应用的需求动态调整垃圾回收的频率和时间，以达到最佳的性能表现。

缺点：在追求高吞吐量的同时，可能会导致垃圾回收的停顿时间相对较长，不太适合对响应时间要求苛刻的应用。

适用场景：适用于注重吞吐量的应用，如服务器端应用，这些应用通常需要处理大量的请求，对系统的整体性能和处理能力要求较高。

-XX:+UseParallelGC：设置 Parallel 收集器。
-XX:+UseParallelOldGC：设置 Parallel Old 收集器。

- 多线程
- STW（Stop The World）相对少
- 高效利用CPU资源
```

- G1 收集器（新生代部分）

```md
工作原理：G1 收集器将堆内存划分为多个大小相等的 Region，它会跟踪每个 Region 中垃圾的堆积程度，在回收时优先处理垃圾最多的 Region。在新生代回收时，采用复制算法，将存活对象复制到其他空的 Region 中。

优点：可以更精确地控制垃圾回收的停顿时间，避免了传统收集器在回收时可能出现的长时间停顿。同时，它能够根据不同 Region 的情况动态调整回收策略，提高了回收效率。

缺点：由于需要跟踪每个 Region 的状态，会增加一定的内存开销和管理复杂度。

适用场景：适用于对停顿时间有严格要求，并且堆内存较大的应用，如大型企业级应用。
```

老年代垃圾回收器

- Serial Old 收集器

```md
工作原理：是 Serial 收集器在老年代的版本，采用标记 - 压缩算法。它是单线程的，在回收老年代垃圾时，会暂停所有用户线程，逐个对老年代中的对象进行标记和压缩整理。

优点：实现简单，在单线程环境下没有线程切换的开销，对于内存较小、对象相对较少的老年代，回收效率尚可。

缺点：会导致长时间的用户线程停顿，尤其是在处理大量垃圾时，停顿时间会比较长，影响应用的响应性。

适用场景：适用于小型应用或者对响应时间要求不高的应用，在 Java 6 及之前的版本中，常作为 CMS 收集器出现 Concurrent Mode Failure 时的后备收集器。
```

- Parallel Old 收集器

```md
工作原理：是 Parallel Scavenge 收集器在老年代的对应版本，采用多线程的标记 - 压缩算法。它通过多个线程同时对老年代进行垃圾回收，以提高回收效率，减少停顿时间。

优点：多线程并行回收，能够充分利用多核处理器的优势，在处理大量垃圾时，相比 Serial Old 收集器，能显著缩短回收时间，提高系统的吞吐量。

缺点：虽然减少了停顿时间，但在多核环境下，线程之间的协调和同步会带来一定的开销。

适用场景：适用于注重吞吐量的应用，与 Parallel Scavenge 收集器配合使用，能在老年代和新生代都提供较高的吞吐量，适合服务器端等对性能要求较高的应用。
```

- CMS（Concurrent Mark Sweep）收集器

```md
工作原理：是一种以获取最短回收停顿时间为目标的收集器。它的整个回收过程分为四个阶段，包括初始标记、并发标记、重新标记和并发清除。初始标记和重新标记阶段需要暂停用户线程，而并发标记和并发清除阶段可以与用户线程并发执行。

优点：在垃圾回收过程中，大部分时间可以与用户线程并发执行，所以对应用的响应时间影响较小，能够提供较好的用户体验。

缺点：并发执行时会占用一定的 CPU 资源，可能会导致应用程序的性能下降。而且由于采用标记 - 清除算法，会产生内存碎片，当内存碎片过多时，可能会导致不得不提前进行 Full GC，甚至出现 Concurrent Mode Failure，退化为 Serial Old 收集器进行垃圾回收。

适用场景：适用于对响应时间要求较高的应用，如 Web 应用、交互性较强的应用等。

- 初始标记：仅仅标记一下 GC Roots 能直接关联到的对象，速度很快，仍然需要停顿用户线程。单个GC线程执行。
- 并发标记：从 GC Roots 开始对堆中对象进行可达性分析，找出存活对象。耗时较长，但可与用户线程并发执行。
- 重新标记：因为上一个过程是并发进行的，所以有些对象在标记过程中新产生的，导致没有标记上，所以这个过程需要修正，将这些没标记上的重新标记. 多个GC线程执行。用户线程停顿。
- 并发清理： 开始堆三色标记后需要处理的对象进行清理，这个过程并发执行. 用户线程也执行.
- 并发重置： 将存活对象上的标记清除, 释放空间. 用户线程执行.

- STW 停顿时间短.
- 缺点：对CPU资源敏感，在并发阶段可能会出现"Concurrent Mode Failure"失败，导致Full GC。
- 产生浮动垃圾，空间碎片,可以在清理后开启空间压缩处理
- 如果清理不干净，会频繁出现full gc.
- 适用场景：适用于对响应时间要求较高的应用，如 Web 应用、交互性较强的应用等。


-XX:+UseConcMarkSweepGC：设置 CMS 收集器。
-XX:+UseCMSCompactAtFullCollection：设置 CMS 收集器在 Full GC 后进行内存碎片整理。
-XX:CMSFullGCsBeforeCompaction：设置 CMS 收集器在执行多少次 Full GC 后进行一次内存碎片整理。
-XX:ConcGCThreads：设置 CMS 收集器并发线程数。
-XX:+CMSClassUnloadingEnabled：设置 CMS 收集器对类的卸载。
-XX:+CMSParallelRemarkEnabled：设置 CMS 收集器并行Remark。
```

- G1 收集器（老年代部分）

  为了更好利用CPU资源，G1 收集器将堆内存划分为多个大小相等的 Region，每个 Region 都可以包含若干个小的 Eden 区、两个 Survivor 区，以及一个或多个老年代区。
  满足最小的stw. 具有高吞吐量.

```md
工作原理：与新生代回收类似，也是基于 Region (区)的概念。在老年代回收时，同样会根据 Region 中垃圾的堆积情况，优先处理垃圾最多的 Region。采用标记 - 压缩算法，避免了内存碎片的产生。

优点：可以实现可预测的停顿时间，能够在有限的时间内尽量回收更多的垃圾。同时，由于采用了标记 - 压缩算法，不会像 CMS 收集器那样产生大量内存碎片。

缺点：回收过程较为复杂，需要更多的计算资源来跟踪和管理 Region 的状态。

适用场景：对于堆内存较大、对停顿时间要求严格的应用，尤其是那些无法承受长时间停顿的应用，G1 收集器在老年代的回收上表现出色。

- 在新生代和老年代的基础上，加了一个存放大对象的区域
- 将整个内存区域全部划分成大小相同的网格region
- 每个region都可以包含eden、两个survivor、老年代,大对象区域
- 大对象的定义是超过region的50%
- 如果一个大对象存放一个region不下，则会跨越多个region区域
- 可以通过参数控制stw时间,默认是10ms

回收过程

- 初始标记：仅仅标记一下 GC Roots 能直接关联到的对象，速度很快，仍然需要停顿用户线程。单个GC线程执行。
- 并发标记：从 GC Roots 开始对堆中对象进行可达性分析，找出存活对象。耗时较长，但可与用户线程并发执行。用户线程和GC线程同时执行。
- 最终标记(重新标记)：为了修正在并发标记期间因用户程序继续运作而导致新的对象产生的那一部分对象， 进行重新标记。
- 筛选回收(清理回收)：根据每个region回收成本排序，然后按照用户期望的停顿时间进行计算，应该回收哪些region,才能满足停顿时间要求. 多个GC线程执行, 用户线程停顿。达到停顿时间才进行回收.

特点：
- 并发与并行
- 空间整合region
- 可预测的停顿时间

垃圾分类
- Yong GC: eden区满，根据计算回收region成本与预期的停顿时间，选择回收哪些region。如果接近就进行YongGC，否则新增Region作为Eden区存放对象.
- Mixed GC: 当老年代region占用率达到阈值，触发MixedGC，将年轻代、大对象回收，如果回收发现还没有足够空间，则触发FullGC。
- Full GC： STW ,单线程标记清理、标记压缩.

参数

- -XX:+UseGC： 启用GC。
- -XX:G1HeapRegionSize：设置Region大小。
- -XX:MaxGCPauseMillis：设置最大GC停顿时间。




- -XX:+PrintGC：打印GC信息。
- -XX:+PrintGCDetails：打印GC详细信息。
```


### 获取内存dump文件

- jmap：获取堆内存信息，包括堆内存使用情况、GC回收情况等。
- jstat：获取GC回收统计信息，包括GC次数、GC时间、GC暂停时间等。
- jinfo：获取JVM配置信息。
- jstack：获取线程堆栈信息。
  
### JVM 常见的参数配置

- -Xms：设置初始堆内存大小。
- -Xmx：设置最大堆内存大小。
- -Xmn：设置新生代大小。
- -XX:NewRatio：设置新生代和老年代的比例。
- -XX:SurvivorRatio：设置新生代中Eden区与Survivor区的比例。
- -XX:MaxTenuringThreshold：设置对象在新生代的最大年龄。
- -XX:TargetSurvivorRatio：设置Survivor区中对象的年龄的目标值。
- -XX:MetaspaceSize：设置元空间初始内存。
- -XX:MaxMetaspaceSize：设置元空间最大内存。
- -XX:UseConcMarkSweepGC：设置使用CMS垃圾回收器。
- -XX:UseG1GC：设置使用G1垃圾回收器。

java 启动带jvm的命令行:

```java
java -Xms1024m -Xmx1024m -Xmn512m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:TargetSurvivorRatio=50 -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=dump -jar app.jar
```

## 如何解决并发标记过程中：多标和漏标的情况

- 三色标记
- 增量更新
- 原始快照

并发标记带来的问题

在cms和g1收集器，都是用了并发标记，用户线程和gc线程同时执行，导致标记过程中，多标和漏标的情况。
在并发收集过程中，或多或少产生一些对象引用变化，会产生多标或漏标的情况。

### 三色标记法

黑--》灰--》白

- 白色：对象在gc roots可达，且没有被标记过。
- 灰色：对象在gc roots可达，但被标记过。至少有一个引用没有被标记过.
- 黑色：对象在gc roots可达，且被标记过。被垃圾收集器扫描过，这个对象所有引用都被全部扫描过，黑色存活，不会被回收。

### 多标一定要解决么？

如果一个对象初始标记为黑色，但是在并发标记过程中，这个对象引用发生了变化，变成需要回收的对象，导致应该回收的对象被标记成需要存活的对象黑色，这就是多标，会导致这个对象变成浮动垃圾.

其实针对这种现场，可以先不用解决，等下一次gc的时候再解决。

### 漏标

回收了不该回收的对象，这就是漏标。后果严重.

本应被标记为存活的对象没有被标记，从而可能被错误地当作垃圾回收。

```md
初始对象引用关系
A -> B -> C
并发标记过程中的操作
断开了 B 对 C 的引用。
建立了 A 对 C 的引用。

假设垃圾收集器已经标记了 A 和 B，但在标记过程中还未处理到 C。当应用程序线程修改引用关系后，由于垃圾收集器没有及时感知到 A 对 C 的新引用，就可能会漏标 C。

这样，在后续的垃圾回收阶段，C 就可能被错误地当作垃圾回收，而实际上 C 仍然是存活对象。
```

解决漏标问题的方法

1. 增量更新：在并发标记过程中，只对新增的引用进行标记，而不是对所有引用进行标记。
2. 原始快照：在并发标记过程中，记录下所有对象引用的快照，然后再进行标记。

```md
SATB 算法的核心思想是在并发标记开始时，对堆内存进行一个 “快照”，记录此时所有对象的引用关系。在并发标记过程中，如果应用程序线程修改了对象的引用关系，就会产生相应的 “写屏障”，将这些修改记录下来。在重新标记阶段，垃圾收集器会根据这些记录对对象进行重新标记，从而避免漏标问题。

增量更新： 当白色对象被重新指定引用时，如果被指定的对象标记成黑色，就将这个引用关系记录下来，等并发标记结束后，将记录下来的这些引用重新扫描一遍，以黑色为根，重新标记所有对象。
```
