# 锁

## 锁的种类

- 共享锁（S锁）：允许多个事务同时读取同一行数据，但不允许更新。
- 排他锁（X锁）：允许独占访问和修改数据，其他事务必须等待锁释放后才能访问。
- 行级锁：是InnoDB存储引擎特有的锁机制，允许对单个行进行加锁，实现更细粒度的并发控制。
- 表级锁：是MyISAM存储引擎特有的锁机制，对整个表加锁，实现更高的并发控制。

- 表级锁：锁定整张表，对整个表进行加锁，并发效率不高。
  - IX： 意向排他锁
  - IS： 意向共享锁
  - S： 共享锁
  - X： 排他锁
- 行级锁：锁定一行数据，对单个行进行加锁，并发效率高。
  - S： 共享锁
  - X： 排他锁
  - Record Lock： 记录锁，锁定一行记录，对记录加锁，其他事务不能修改该记录。
  - Gap Lock： 间隙锁，锁定范围内的记录，对记录加锁，其他事务不能插入该范围内的记录。
  - Next-Key Lock： 前开后闭锁，锁定范围内的记录，对记录加锁，其他事务不能插入该范围内的记录，也不能在范围内插入记录。
- 页级锁：锁定一页数据，对一页中的多个行进行加锁，并发效率高。

## 锁的粒度

- 表级锁：锁定整张表，对整个表进行加锁，并发效率不高。
- 行级锁：锁定一行数据，对单个行进行加锁，并发效率高。
- 页级锁：锁定一页数据，对一页中的多个行进行加锁，并发效率高。

## 死锁

死锁是指两个或两个以上的事务在同一资源上相互占用，并请求对方释放资源，导致恶性循环，使得数据库资源一直处于锁定状态。

解决死锁的方法：

- 超时回退：当两个事务在同一资源上相互等待超过一定的时间，则认为发生了死锁，并自动回退，释放资源。
- 死锁检测和回滚：当检测到死锁发生时，立即回滚其中一个事务，释放资源，并通知其他事务。
- 资源预留：为每个事务分配一定的资源，使得资源总分配量小于系统总资源。
- 主从备份：当发生死锁时，主服务器挂起，等待超时或主服务器死锁解除后，从服务器接管工作。
- 串行化调度：通过将事务调度到串行顺序执行，避免死锁。
- 并发度控制：通过限制并发事务数，避免死锁。
- 隔离级别：通过隔离级别来控制事务的并发性，避免死锁。
- 回滚并重新执行：当发生死锁时，回滚事务，并重新执行。
- 其他方法：如，将事务分解为多个小事务，避免死锁。
- 避免死锁：在设计数据库表结构时，尽量避免使用不必要的外键，避免长事务，避免大事务。
